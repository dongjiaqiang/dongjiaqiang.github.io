
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>Dong&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="rookiedong">
    

    
    <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Dong's Blog">
<meta property="og:url" content="http://www.gohell.com.cn/index.html">
<meta property="og:site_name" content="Dong's Blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Dong's Blog">
<meta name="twitter:description">

    
    <link rel="alternative" href="/atom.xml" title="Dong&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Dong&#39;s Blog" title="Dong&#39;s Blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Dong&#39;s Blog">Dong&#39;s Blog</a></h1>
				<h2 class="blog-motto">less is more</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:www.gohell.com.cn">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/12/27/hadoop_serialization/" title="Hadoop源码阅读之Hadoop序列化机制(基于Hadoop 1.0.0版本)" itemprop="url">Hadoop源码阅读之Hadoop序列化机制(基于Hadoop 1.0.0版本)</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="rookiedong" target="_blank" itemprop="author">rookiedong</a>
		
  <p class="article-time">
    <time datetime="2015-12-27T07:35:42.000Z" itemprop="datePublished"> 发表于 2015-12-27</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="序列化">序列化</h2><p> 所谓对象的序列化就是将对象编码为一个字节流,和从字节流中重构出对象.将一个对象编码为一个字节流.序列化主要有三种用途:</p>
<ul>
<li>作为一种持久化格式:一个对象被序列化后,它的编码可以被存储到磁盘中,供以后反序列使用.</li>
<li>作为一种通信数据格式:序列化结果可以从一个正在运行的虚拟机,通过网络被传递到另一个虚拟机中.</li>
<li><p>作为一种拷贝,克隆机制:将对象序列化到内存的缓存区中,然后通过反序列化,可以得到一个对已存在对象进行深拷贝的新对象.</p>
<h2 id="Java序列化机制">Java序列化机制</h2><p>Java序列化机制将对象转换为连续的byte数据,这些数据可以在日后还原为原先的对象状态,该机制还能自动处理不同OS上的差异.</p>
<h2 id="Hadoop序列化机制">Hadoop序列化机制</h2><p>和Java序列化机制不同,Hadoop序列化机制通过调用对象的write方法,将对象序列化到流中.反序列化的过程也是类似,通过对象的readFields方法,从流中读取数据.<br>Java序列化机制中,反序列化过程会不断地创建新的对象,但在Hadoop反序列机制的反序列化过程中,用户可以复用对象.</p>
</li>
</ul>
<p>下面的代码比较Hadoop序列化机制和Java序列化机制在数据持久化方面的不同<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每个需要序列化的对象都要实现Writable接口,并实现其中的两个方法,Java序列化机制只需要实现Seriable接口,而这个接口仅是一个标记接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarWritable</span> <span class="keyword">implements</span> <span class="title">Writable</span>,<span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CarWritable</span><span class="params">(String brand, <span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.brand = brand;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CarWritable</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBrand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> brand;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"CarWritable&#123;"</span> +</span><br><span class="line">                <span class="string">"brand='"</span> + brand + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", price="</span> + price +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出序列化对象到流中</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(DataOutput dataOutput)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        dataOutput.writeUTF(brand);</span><br><span class="line">        dataOutput.writeInt(price);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从流中读取反序列对象,为了效率需要复用现有对象</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFields</span><span class="params">(DataInput dataInput)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.brand=dataInput.readUTF();</span><br><span class="line">        <span class="keyword">this</span>.price=dataInput.readInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//每个需要序列化的对象都要实现Writable接口,并实现其中的两个方法,Java序列化机制只需要实现Seriable接口,而这个接口仅是一个标记接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonWritable</span> <span class="keyword">implements</span> <span class="title">Writable</span>,<span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String job;</span><br><span class="line">    <span class="keyword">private</span> CarWritable carWritable;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"PersonWritable&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">", job='"</span> + job + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", carWritable="</span> + carWritable +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonWritable</span><span class="params">(String name, <span class="keyword">int</span> age, String job,CarWritable carWritable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.job = job;</span><br><span class="line">        <span class="keyword">this</span>.carWritable=carWritable;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonWritable</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setJob</span><span class="params">(String job)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.job = job;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getJob</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> job;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出序列化对象到流中</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(DataOutput dataOutput)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        dataOutput.writeUTF(name);</span><br><span class="line">        dataOutput.writeInt(age);</span><br><span class="line">        dataOutput.writeUTF(job);</span><br><span class="line">        carWritable.write(dataOutput);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从流中读取反序列对象,为了效率需要复用现有对象</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFields</span><span class="params">(DataInput dataInput)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        name=dataInput.readUTF();</span><br><span class="line">        age=dataInput.readInt();</span><br><span class="line">        job=dataInput.readUTF();</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.carWritable==<span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">this</span>.carWritable=<span class="keyword">new</span> CarWritable();</span><br><span class="line">        <span class="keyword">this</span>.carWritable.readFields(dataInput);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span> <span class="keyword">throws</span> IOException,InterruptedException,ClassNotFoundException</span>&#123;</span><br><span class="line">        <span class="comment">//使用Hadoop序列化机制将对象持久化到本地磁盘并从本地磁盘中反序列到堆中</span></span><br><span class="line">        PersonWritable personWritable=<span class="keyword">new</span> PersonWritable(<span class="string">"Liu"</span>,<span class="number">22</span>,<span class="string">"Driver"</span>,<span class="keyword">new</span> CarWritable(<span class="string">"Cheery"</span>,<span class="number">120</span>));</span><br><span class="line">        DataOutputStream outputStream=<span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"C:\\Users\\think\\Desktop\\openjdk\\jdk\\src\\share\\native\\java\\io\\person"</span>)));</span><br><span class="line">        personWritable.write(outputStream);</span><br><span class="line">        outputStream.flush();</span><br><span class="line">        outputStream.close();</span><br><span class="line"></span><br><span class="line">        DataInputStream inputStream=<span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"C:\\Users\\think\\Desktop\\openjdk\\jdk\\src\\share\\native\\java\\io\\person"</span>)));</span><br><span class="line">        <span class="comment">//Hadoop序列化机制可以复用已创建的对象,减少了创建对象的开销</span></span><br><span class="line">        personWritable.readFields(inputStream);</span><br><span class="line">        System.out.println(personWritable);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用Java序列化机制将对象持久化到本地磁盘并从本地磁盘中反序列到堆中</span></span><br><span class="line">        PersonWritable personWritable2=<span class="keyword">new</span> PersonWritable(<span class="string">"Li"</span>,<span class="number">21</span>,<span class="string">"Programmer"</span>,<span class="keyword">new</span> CarWritable(<span class="string">"Honda"</span>,<span class="number">344</span>));</span><br><span class="line">        ObjectOutputStream objectOutputStream=<span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"dd"</span>)));</span><br><span class="line">        objectOutputStream.writeObject(personWritable2);</span><br><span class="line">        objectOutputStream.flush();</span><br><span class="line">        objectOutputStream.close();</span><br><span class="line"></span><br><span class="line">        ObjectInputStream objectInputStream=<span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"dd"</span>)));</span><br><span class="line">        <span class="comment">//Java序列化机制每次反序列一个对象时,都是创建了一个新的对象,相对来说消耗比较大</span></span><br><span class="line">        PersonWritable personWritable3=(PersonWritable)objectInputStream.readObject();</span><br><span class="line">        System.out.println(personWritable3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用ObjectWritable类来将对象序列化到本地并从本地反序列化到Java堆中</span></span><br><span class="line">        DataOutputStream dataOutputStream=<span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"ee"</span>)));</span><br><span class="line">        PersonWritable personWritable4=<span class="keyword">new</span> PersonWritable(<span class="string">"Ma"</span>,<span class="number">22</span>,<span class="string">"Programmer"</span>,<span class="keyword">new</span> CarWritable(<span class="string">"Mazda"</span>,<span class="number">244</span>));</span><br><span class="line">        ObjectWritable.writeObject(dataOutputStream,personWritable4,personWritable4.getClass(),<span class="keyword">new</span> Configuration());</span><br><span class="line">        dataOutputStream.flush();</span><br><span class="line">        dataOutputStream.close();</span><br><span class="line">        DataInputStream dataInputStream=<span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"ee"</span>)));</span><br><span class="line">        Object object=ObjectWritable.readObject(dataInputStream,<span class="keyword">new</span> ObjectWritable(),<span class="keyword">new</span> Configuration());</span><br><span class="line">        System.out.println(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="典型的Writable类型剖析">典型的Writable类型剖析</h3><p> 这里将剖析ObjectWritable类型,该类型可应用于Hadoop远程过程调用中参数的序列化和反序列化.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectWritable</span> <span class="keyword">implements</span> <span class="title">Writable</span>, <span class="title">Configurable</span> </span>&#123;</span><br><span class="line">	<span class="comment">//instance实例的类对象</span></span><br><span class="line">    <span class="keyword">private</span> Class declaredClass;</span><br><span class="line">    <span class="comment">//Object类型的实例,类型可以为空类型,基本类型,其他Writable类型</span></span><br><span class="line">    <span class="keyword">private</span> Object instance;</span><br><span class="line">    <span class="comment">//配置对象</span></span><br><span class="line">    <span class="keyword">private</span> Configuration conf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存有基本类型的class对象和其字符串名字的map,这个保存阶段发生在static代码块中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Class&lt;?&gt;&gt; PRIMITIVE_NAMES = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObjectWritable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObjectWritable</span><span class="params">(Object instance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.set(instance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObjectWritable</span><span class="params">(Class declaredClass, Object instance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.declaredClass = declaredClass;</span><br><span class="line">        <span class="keyword">this</span>.instance = instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">getDeclaredClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.declaredClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object instance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.declaredClass = instance.getClass();</span><br><span class="line">        <span class="keyword">this</span>.instance = instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"OW[class="</span> + <span class="keyword">this</span>.declaredClass + <span class="string">",value="</span> + <span class="keyword">this</span>.instance + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFields</span><span class="params">(DataInput in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        readObject(in, <span class="keyword">this</span>, <span class="keyword">this</span>.conf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(DataOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        writeObject(out, <span class="keyword">this</span>.instance, <span class="keyword">this</span>.declaredClass, <span class="keyword">this</span>.conf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个静态方法可以实现将Object类型的实例序列化为字节流</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(DataOutput out, Object instance, Class declaredClass, Configuration conf)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    	<span class="comment">//instance实例为空时</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> ObjectWritable.NullInstance(declaredClass, conf);</span><br><span class="line">            declaredClass = Writable.class;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//首先向流写入的是一个代表类对象的名字字符串</span></span><br><span class="line">        UTF8.writeString(out, declaredClass.getName());</span><br><span class="line">        <span class="comment">//如果这个类对象代表的是数组</span></span><br><span class="line">        <span class="keyword">if</span>(declaredClass.isArray()) &#123;</span><br><span class="line">        	<span class="comment">//则首先获取数组的长度</span></span><br><span class="line">            <span class="keyword">int</span> length = Array.getLength(instance);</span><br><span class="line">            <span class="comment">//向流中写入数组的长度</span></span><br><span class="line">            out.writeInt(length);</span><br><span class="line">            <span class="comment">//将数组中每个实例都调用writeObject方法写入流中</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">            	<span class="comment">//传入的是数组的每个实例对象,代表数组每个实例对象的类对象,配置信息</span></span><br><span class="line">                writeObject(out, Array.get(instance, i), declaredClass.getComponentType(), conf);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(declaredClass == String.class) &#123;</span><br><span class="line">        	<span class="comment">//如果是字符串类型,则将实例转换为字符串类型,并写入流中</span></span><br><span class="line">            UTF8.writeString(out, (String)instance);</span><br><span class="line">            <span class="comment">//如果是基本类型,则将实例转换为基本类型,并写入流中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(declaredClass.isPrimitive()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(declaredClass == Boolean.TYPE) &#123;</span><br><span class="line">                out.writeBoolean(((Boolean)instance).booleanValue());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(declaredClass == Character.TYPE) &#123;</span><br><span class="line">                out.writeChar(((Character)instance).charValue());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(declaredClass == Byte.TYPE) &#123;</span><br><span class="line">                out.writeByte(((Byte)instance).byteValue());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(declaredClass == Short.TYPE) &#123;</span><br><span class="line">                out.writeShort(((Short)instance).shortValue());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(declaredClass == Integer.TYPE) &#123;</span><br><span class="line">                out.writeInt(((Integer)instance).intValue());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(declaredClass == Long.TYPE) &#123;</span><br><span class="line">                out.writeLong(((Long)instance).longValue());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(declaredClass == Float.TYPE) &#123;</span><br><span class="line">                out.writeFloat(((Float)instance).floatValue());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(declaredClass == Double.TYPE) &#123;</span><br><span class="line">                out.writeDouble(((Double)instance).doubleValue());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(declaredClass != Void.TYPE) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Not a primitive: "</span> + declaredClass);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果是枚举类型,则写入代表枚举类的字符串字面值</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(declaredClass.isEnum()) &#123;</span><br><span class="line">            UTF8.writeString(out, ((Enum)instance).name());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	<span class="comment">//如果不是Writable类型的则抛出异常</span></span><br><span class="line">            <span class="keyword">if</span>(!Writable.class.isAssignableFrom(declaredClass)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Can\'t write: "</span> + instance + <span class="string">" as "</span> + declaredClass);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//写入代表instance实例类对象的字符串名字</span></span><br><span class="line">            UTF8.writeString(out, instance.getClass().getName());</span><br><span class="line">            <span class="comment">//将对象序列化到流中</span></span><br><span class="line">            ((Writable)instance).write(out);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">readObject</span><span class="params">(DataInput in, Configuration conf)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> readObject(in, (ObjectWritable)<span class="keyword">null</span>, conf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这个静态方法实现将流中的数据反序列化为本地对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">readObject</span><span class="params">(DataInput in, ObjectWritable objectWritable, Configuration conf)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    	<span class="comment">//首先获取代表对象的类对象名字</span></span><br><span class="line">        String className = UTF8.readString(in);</span><br><span class="line">        <span class="comment">//首先判断是否是基本类型对象</span></span><br><span class="line">        Class declaredClass = (Class)PRIMITIVE_NAMES.get(className);</span><br><span class="line">        <span class="keyword">if</span>(declaredClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            	<span class="comment">//如果不是则使用Class.forName从本地加载该类对象</span></span><br><span class="line">                declaredClass = conf.getClassByName(className);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException var10) &#123;</span><br><span class="line">            	<span class="comment">//如果没有发现该名字字符串对应的类对象,则抛异常结束</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"readObject can\'t find class "</span> + className, var10);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建一个代表反序列化后的实例引用</span></span><br><span class="line">        Object instance;</span><br><span class="line">        <span class="comment">//如果类型为基本类型,则从流中直接使用read命令反序列化基本类型数据</span></span><br><span class="line">        <span class="keyword">if</span>(declaredClass.isPrimitive()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(declaredClass == Boolean.TYPE) &#123;</span><br><span class="line">                instance = Boolean.valueOf(in.readBoolean());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(declaredClass == Character.TYPE) &#123;</span><br><span class="line">                instance = Character.valueOf(in.readChar());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(declaredClass == Byte.TYPE) &#123;</span><br><span class="line">                instance = Byte.valueOf(in.readByte());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(declaredClass == Short.TYPE) &#123;</span><br><span class="line">                instance = Short.valueOf(in.readShort());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(declaredClass == Integer.TYPE) &#123;</span><br><span class="line">                instance = Integer.valueOf(in.readInt());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(declaredClass == Long.TYPE) &#123;</span><br><span class="line">                instance = Long.valueOf(in.readLong());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(declaredClass == Float.TYPE) &#123;</span><br><span class="line">                instance = Float.valueOf(in.readFloat());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(declaredClass == Double.TYPE) &#123;</span><br><span class="line">                instance = Double.valueOf(in.readDouble());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(declaredClass != Void.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Not a primitive: "</span> + declaredClass);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                instance = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果是数组类型对象</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(declaredClass.isArray()) &#123;</span><br><span class="line">        	<span class="comment">//首先获取数组长度</span></span><br><span class="line">            <span class="keyword">int</span> instanceClass = in.readInt();</span><br><span class="line">            <span class="comment">//使用Java反射机制创建长度为instanceClass的空数组</span></span><br><span class="line">            instance = Array.newInstance(declaredClass.getComponentType(), instanceClass);</span><br><span class="line">            <span class="comment">//从流中依次反序列化出数组成员实例并放到创建的空数组中</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> str = <span class="number">0</span>; str &lt; instanceClass; ++str) &#123;</span><br><span class="line">                Array.set(instance, str, readObject(in, conf));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果是字符串类型,则从流中反序列化出字符串类型实例</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(declaredClass == String.class) &#123;</span><br><span class="line">            instance = UTF8.readString(in);</span><br><span class="line">            <span class="comment">//如果是枚举类型,则从流中反序列出枚举类型实例</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(declaredClass.isEnum()) &#123;</span><br><span class="line">            instance = Enum.valueOf(declaredClass, UTF8.readString(in));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Class var11 = <span class="keyword">null</span>;</span><br><span class="line">            String var12 = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            	<span class="comment">//如果是Writable类型的元素,则从流中读出代表该实例的类对象的字符串名字</span></span><br><span class="line">                var12 = UTF8.readString(in);</span><br><span class="line">                <span class="comment">//使用Class.forName方法使用类元素的字符串名字从本地创建类对象</span></span><br><span class="line">                var11 = conf.getClassByName(var12);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException var9) &#123;</span><br><span class="line">            	<span class="comment">//如果没找到,则抛运行时异常结束</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"readObject can\'t find class "</span> + var12, var9);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//利用Java反射机制使用Class类对象创建一个实例(使用默认构造器)</span></span><br><span class="line">            Writable writable = WritableFactories.newInstance(var11, conf);</span><br><span class="line">            <span class="comment">//从流中反序列出该实例</span></span><br><span class="line">            writable.readFields(in);</span><br><span class="line">            instance = writable;</span><br><span class="line">            <span class="comment">//如果该实例是空实例</span></span><br><span class="line">            <span class="keyword">if</span>(var11 == ObjectWritable.NullInstance.class) &#123;</span><br><span class="line">                declaredClass = ((ObjectWritable.NullInstance)writable).declaredClass;</span><br><span class="line">                instance = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(objectWritable != <span class="keyword">null</span>) &#123;</span><br><span class="line">            objectWritable.declaredClass = declaredClass;</span><br><span class="line">            objectWritable.instance = instance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConf</span><span class="params">(Configuration conf)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.conf = conf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Configuration <span class="title">getConf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.conf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        PRIMITIVE_NAMES.put(<span class="string">"boolean"</span>, Boolean.TYPE);</span><br><span class="line">        PRIMITIVE_NAMES.put(<span class="string">"byte"</span>, Byte.TYPE);</span><br><span class="line">        PRIMITIVE_NAMES.put(<span class="string">"char"</span>, Character.TYPE);</span><br><span class="line">        PRIMITIVE_NAMES.put(<span class="string">"short"</span>, Short.TYPE);</span><br><span class="line">        PRIMITIVE_NAMES.put(<span class="string">"int"</span>, Integer.TYPE);</span><br><span class="line">        PRIMITIVE_NAMES.put(<span class="string">"long"</span>, Long.TYPE);</span><br><span class="line">        PRIMITIVE_NAMES.put(<span class="string">"float"</span>, Float.TYPE);</span><br><span class="line">        PRIMITIVE_NAMES.put(<span class="string">"double"</span>, Double.TYPE);</span><br><span class="line">        PRIMITIVE_NAMES.put(<span class="string">"void"</span>, Void.TYPE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//NullInstance类代表了空对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NullInstance</span> <span class="keyword">extends</span> <span class="title">Configured</span> <span class="keyword">implements</span> <span class="title">Writable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Class&lt;?&gt; declaredClass;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">NullInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>((Configuration)<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">NullInstance</span><span class="params">(Class declaredClass, Configuration conf)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(conf);</span><br><span class="line">            <span class="keyword">this</span>.declaredClass = declaredClass;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//反序列的只是从流中读取代表类对象的字符串名字,并使用代表该类的字符串名字利用反射技术使用这个字符串名字生成一个类对象</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFields</span><span class="params">(DataInput in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            String className = UTF8.readString(in);</span><br><span class="line">            <span class="comment">//如果是基本类型,则直接从缓存的map中查找</span></span><br><span class="line">            <span class="keyword">this</span>.declaredClass = (Class)ObjectWritable.PRIMITIVE_NAMES.get(className);</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.declaredClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                	<span class="comment">//如果没找到,使用Class.forName方法从本地加载这个类对象</span></span><br><span class="line">                    <span class="keyword">this</span>.declaredClass = <span class="keyword">this</span>.getConf().getClassByName(className);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException var4) &#123;</span><br><span class="line">                	<span class="comment">//如果没有找到,抛运行时异常结束</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(var4.toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//序列化的只是代表空对象的类的字符串名字</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(DataOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            UTF8.writeString(out, <span class="keyword">this</span>.declaredClass.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下图展现Hadoop序列化机制序列化和反序列化基本类型数据,字符串类型数据,基本类型数组的机制<br><img src="http://7xonn1.com1.z0.glb.clouddn.com/hadoop%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B61.png" alt="Hadoop Serialization"></p>
<p>下图展现Hadoop序列化机制序列化和反序列化Writable类型,枚举类型,Null引用的机制<br><img src="http://7xonn1.com1.z0.glb.clouddn.com/hadoop%E5%BA%8F%E5%88%97%E5%8C%962.png" alt="Hadoop Serialization"></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/12/26/function_program_in_java_8/" title="Java 8 函数式编程" itemprop="url">Java 8 函数式编程</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="rookiedong" target="_blank" itemprop="author">rookiedong</a>
		
  <p class="article-time">
    <time datetime="2015-12-25T22:16:43.000Z" itemprop="datePublished"> 发表于 2015-12-26</time>
    
  </p>
</header>
    <div class="article-content">
        
        
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/12/25/java_nio/" title="Java NIO类型" itemprop="url">Java NIO类型</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="rookiedong" target="_blank" itemprop="author">rookiedong</a>
		
  <p class="article-time">
    <time datetime="2015-12-25T02:53:07.000Z" itemprop="datePublished"> 发表于 2015-12-25</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="Buffer类">Buffer类</h2>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/12/21/use_vim/" title="vim的使用" itemprop="url">vim的使用</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="rookiedong" target="_blank" itemprop="author">rookiedong</a>
		
  <p class="article-time">
    <time datetime="2015-12-21T06:36:19.000Z" itemprop="datePublished"> 发表于 2015-12-21</time>
    
  </p>
</header>
    <div class="article-content">
        
        
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/12/17/hadoop_rpc/" title="Hadoop源码阅读之Hadoop RPC框架解析(基于Hadoop 1.0.0版本)" itemprop="url">Hadoop源码阅读之Hadoop RPC框架解析(基于Hadoop 1.0.0版本)</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="rookiedong" target="_blank" itemprop="author">rookiedong</a>
		
  <p class="article-time">
    <time datetime="2015-12-17T15:20:21.000Z" itemprop="datePublished"> 发表于 2015-12-17</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="Hadoop_RPC框架概述">Hadoop RPC框架概述</h2><h2 id="代理模式与Java动态代理">代理模式与Java动态代理</h2><p>在了解Java动态代理之前,先了解一下代理模式</p>
<h3 id="代理模式">代理模式</h3><p>代理模式是一种设计模式,其定义是:</p>
<ul>
<li>为另一个对象提供一个替身或占位符以控制对这个对象的访问.</li>
</ul>
<p>使用代理模式创建代表对象,让代表对象控制对某对象的访问,被代理的对象可以是远程的对象,创建开销大的对象或需要安全控制的对象.</p>
<p>下图展现了代理模式的类图<br><img src="http://7xonn1.com1.z0.glb.clouddn.com/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.png?imageView/2/w/519/q/80" alt="Proxy Pattern Diagram"></p>
<p>1.首先是Subject接口,它为RealSubject和Proxy提供了接口.通过实现同一个接口,Proxy在RealSubject出现的地方取代它<br>2.RealSubject是真正做事的对象,它是被Proxy代理和控制访问的对象<br>3.Proxy持有RealSubject的引用.客户端与RealSubject的交互都须通过Proxy.因为两者都实现了同一个接口,所以Proxy可以取代用到RealSubject的任何位置.</p>
<p>代理模式的变体非常多,包括远程代理,虚拟代理等.</p>
<h4 id="远程代理">远程代理</h4><p>远程代理可以比作”远程对象的本地代表”.所谓的远程对象,就是存在于不同Java虚拟机(JVM)堆中.<br>本地代表则是一种可以由本地方法调用的对象,其行为会转发到远程对象中.</p>
<p>你的客户所做的就像是在做远程方法调用,但其实只是调用本地堆中的代理对象上的方法,再由代理处理所有网络通信的底层细节.</p>
<h4 id="虚拟代理">虚拟代理</h4><h3 id="Java动态代理">Java动态代理</h3><p>Java在java.lang.reflect包中有自己的代理支持,利用这个包可以在运行时动态地创建一个代理类,实现一个或多个接口,并将方法的调用转发到你指定的类.因为实际的代理类是运行时创建的,所以称这个Java技术为动态代理.使用Java动态代理技术可以实现对被代理对象的保护</p>
<p>下图展现了Java动态代理的类图<br><img src="http://7xonn1.com1.z0.glb.clouddn.com/java动态代理.png?imageView/2/w/519/q/80" alt="Java Dynamic Proxy Diagram"></p>
<p>这里Java为你创建了Proxy类,所以需要某种方式告诉Proxy类你需要其实现的行为.由于无法将你的代码放在Proxy类中,所以你需要实现一个InvocationHandler类.该类的工作就是响应代理的任何调用,这是实际进行工作的对象.</p>
<h3 id="Java动态代理的使用">Java动态代理的使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义代理类和被代理类(服务类)共同实现的接口(服务接口)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CaculatorProtocol</span>  </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subtrace</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编写被代理类(服务类)并实现CaculatorProtocol接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> <span class="keyword">implements</span> <span class="title">CaculatorProtocol</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subtrace</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编写CaculatorHandler类并实现InvocationHandler接口(这个类将响应代理的任何调用,用户在invoke方法中实现对代理方法调用的响应)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CaculatorHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">	<span class="comment">//真实对象</span></span><br><span class="line">    <span class="keyword">private</span> Object orjOriginal;</span><br><span class="line">    <span class="comment">//在CaculatorHandler类的构造器中传入一个被代理对象(服务对象),CaculatorHandler对象可以控制客户端对被代理对象的访问</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CaculatorHandler</span><span class="params">(Object orjOriginal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orjOriginal = orjOriginal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用户在invoke方法中实现对代理调用的响应,其中参数proxy是代理对象,method是被调用的代理对象上的方法,args是方法的参数列表</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//将对代理对象的调用转换为对真实对象的调用并返回结果</span></span><br><span class="line">        Object result=method.invoke(<span class="keyword">this</span>.orjOriginal,args);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Java动态代理的使用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    	<span class="comment">//创建一个被代理对象(服务对象)</span></span><br><span class="line">		CaculatorProtocol server=<span class="keyword">new</span> Server();</span><br><span class="line">		<span class="comment">//创建一个InvocationHandler对象,该对象持有被代理对象(服务对象)</span></span><br><span class="line">        InvocationHandler handler=<span class="keyword">new</span> CaculatorHandler(server);</span><br><span class="line">        <span class="comment">//使用Proxy类的newProxyInstance方法创建一个代理对象,传入服务接口的类加载器对象,服务接口的类对象,InvocationHandler对象(持有真实对象)</span></span><br><span class="line">        CaculatorProtocol client= (CaculatorProtocol)Proxy.newProxyInstance(CaculatorProtocol.class.getClassLoader(),<span class="keyword">new</span> Class[]&#123;CaculatorProtocol.class&#125;,handler);</span><br><span class="line">        <span class="comment">//在代理对象上进行方法调用</span></span><br><span class="line">        System.out.println(client.add(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Java反射机制">Java反射机制</h2><h2 id="Java网络编程">Java网络编程</h2><p>Java网络程序建立于TCP/IP协议之上,致力于实现应用层.传输层向应用层提供了套接字接口,其封装了下层的数据传输细节.应用层通过套接字接口与远程主机进行连接并输出数据.</p>
<p>java.net.Socket类是Java完成客户端TCP操作的基础类.</p>
<h3 id="客户端构造过程">客户端构造过程</h3><p>步骤一: 创建客户端Socket</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Socket soc=<span class="keyword">new</span> Socket(serverHost,port);</span><br></pre></td></tr></table></figure>
<p>步骤二:创建输出,输入流和向服务器端发送数据和从服务器端接受数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DataInputStream in=<span class="keyword">new</span> DataInputStream(soc.getInputStream());</span><br><span class="line">DataOutputStream out=<span class="keyword">new</span> DataOutputStream(soc.getOutputStream());</span><br></pre></td></tr></table></figure>
<p>步骤三:端开连接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">soc.close()</span><br></pre></td></tr></table></figure>
<h3 id="Socket选项">Socket选项</h3><ul>
<li><p>TCP_NODELAY 设置TCP_NODELAY为true会确保包尽可能快地发送,而不管包的大小.正常情况下,小数据包在发送前会组合为更大的包.设置其为true关闭了底层Socket的缓冲,设置为false则重新开启底层Socket的缓冲</p>
</li>
<li><p>SO_LINGER 这个选项指定了Socket关闭时如何处理尚未发送的数据报,默认情况下,close方法立即返回,但系统依然会尝试发送剩余的数据,如果设置为0则会立即丢弃剩余数据,设置为一个正数,close方法阻塞,在该正数时间内,系统将剩余数据发送出去并进行确认.之后,则丢弃未发送数据.</p>
</li>
<li><p>SO_TIMEOUT 正常情况下,尝试从Socket读取数据时,read调用会阻塞尽可能长的时间来得到足够的字节.设置SO_TIMEOUT可以确保这次调用阻塞的时间不会超过某个固定的毫秒数.当时间到期时就会抛出InterruptedException异常,你需要准备捕获这个异常.不过Socket依旧是连接的,你可以再次尝试读取.</p>
</li>
<li><p>SO_KEEPALIVE 如果打开该参数,客户端偶尔会通过一个空闲连接发送一个数据包,以确保服务器未崩溃.如果服务没有响应这个包,客户端会持续尝试11分钟,直到接受了响应为止.如果在12分钟内未接受响应,客户端就关闭连接.如果未打开该参数,空闲的客户端可能会永远存在下去,而无法注意到服务端已经崩溃.</p>
</li>
</ul>
<h3 id="半关闭Socket">半关闭Socket</h3><p>close方法会同时关闭Socket的输入和输出,但有时你希望只关闭连接的另一半,即输入或输出.shutdownInput和shutdownOuput方法可以只关闭连接的另一半.这不会导致Socket被关闭,这会调整与Socket连接的流,使其认为已经到了流的末尾.关闭输入后再读取输入流会返回-1,关闭输出后再写入Socket会抛出异常.</p>
<h3 id="服务器端构造过程">服务器端构造过程</h3><p>对于接受连接的服务器,Java提供了一个ServerSocket类表示服务器Socket.服务器Socket在服务器上运行,监听入站的TCP连接.每个服务器Socket监听服务器机器上的一个端口号.当远程主机上的一个客户端尝试连接这个端口时,服务器就被唤醒,协商建立客户端与服务器间的连接,并返回一个常规的Socket对象,表示两台主机间的Socket.</p>
<p>步骤一: 创建ServerSocket对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket socket=<span class="keyword">new</span> ServerSocket(port);</span><br></pre></td></tr></table></figure>
<p>步骤二: 监听端口号,等待新连接到达</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Socket soc=socket.accept()</span><br></pre></td></tr></table></figure>
<h3 id="Socket选项-1">Socket选项</h3><p>这些选项指定了ServerSocket类所依赖的原生Socket如何发送和接受数据.对于服务器Socket,Java支持如下选项.</p>
<ul>
<li>SO_TIMEOUT 这是accpet方法抛出中断异常前等待入站连接的时间,如果为0,则永远不会超时.</li>
</ul>
<h3 id="完整了客户端与服务端程序">完整了客户端与服务端程序</h3><h2 id="Java_NIO">Java NIO</h2><p>NIO即New IO,它是Java引入的全新的高效的IO机制,同时引入了基于Reactor设计模式的多路复用异步模式.NIO的包中主要包含如下的几种抽象数据类型:</p>
<ul>
<li>Channel(通道) NIO把它支持的IO对象抽象为Channel.其模拟了通信连接,类似于原IO中的流,用户通过它读取和写入数据.</li>
<li>Buffer(缓冲区) Buffer是一块连续的内存区域,一般作为Channel收发数据的载体出现.所有数据通过Buffer对象进行处理.用户不会将字节直接写入通道中,相反,需要将数据写入包含一个或者多个字节的缓冲区.同样,也不会直接从通道中读取字节,而是将数据从通道读入缓冲区,再从缓冲区获取这个字节.</li>
<li>Selector(选择器) Selector提供了监控一个或多个通道当前状态的机制.只要Channel向Selector注册了某种特定事件,便会通知对应的Channel.使用选择器,借助单一线程,就可以对数量庞大的获取IO通道实施监控和维护.</li>
</ul>
<h3 id="Buffer类">Buffer类</h3><p><img src="http://7xonn1.com1.z0.glb.clouddn.com/buffer.png" alt="Buffer"></p>
<h3 id="Channel类">Channel类</h3><p>这里介绍SelectedChannel类,该类支持阻塞和非阻塞IO通信.其主要有如下方法:</p>
<ul>
<li><p>SelectedChannel configureBlocking(boolean block) throws IOException 设置当前Channel的阻塞模式</p>
</li>
<li><p>SelectionKey register(Selector selector,int ops) throws ClosedChannelException 将当前的Channel注册到一个Selector中.selector表示要注册的Selector,ops表示注册事件.返回与注册Channel关联的SelectionKey对象,用于跟踪被注册事件.</p>
</li>
</ul>
<p>SelectedChannel的两个子类是ServerSocketChannel和SocketChannel.ServerSocketChannel用于监听TCP连接.其提供了如下方法:</p>
<ul>
<li><p>ServerSocketChannel open() throws IOException 用于创建ServerSocketChannel的静态工厂,返回的Channel未与任何本地端口号绑定.处于阻塞状态</p>
</li>
<li><p>int select(long timeout) 该方法等待并返回发生的事件.一旦某个注册事件发生后,就会返回对应的SelectionKey数目.否则,一直处于阻塞状态,直到如下四种情况至少发生一种:其他线程调用Selector的wakeup方法,当前select方法被中断,超出等待时间timeout,如果不设置超时时间,表示永远不超时.</p>
</li>
<li><p>Set selectedKeys() Selector捕获已发生事件对应的SelectionKey集合</p>
</li>
<li><p>Selector wakeup() 立刻唤醒当前处于阻塞状态的Selector</p>
</li>
</ul>
<h3 id="SelectionKey类">SelectionKey类</h3><p>ServerSocketChannel或SocketChannel通过register方法向Selector注册事件时,register方法会创建一个SelectionKey对象,用于跟踪事件.在SelectionKey中定义了4种事件:</p>
<ul>
<li>SelectionKey.OP_ACCEPT:接收连接就绪事件,表示服务器接收到客户端连接</li>
<li>SelectionKey.OP_CONNECT:连接就绪事件,表示客户端与服务器连接已经建立</li>
<li>SelectionKey.OP_READ:读就绪事件,表示通道中有可读数据,可执行读操作</li>
<li>SelectionKey.OP_WRITE:写就绪事件,表示可以向通道中写入数据</li>
</ul>
<p>一般而言,ServerSocketChannel向Selector注册SelectionKey.OP_ACCEPT事件,而SocketChannel对象向Selector注册SelectionKey.OP_CONNECT,SelectionKey.OP_READ和SelectionKey.OP_WRITE事件.</p>
<p>其中比较重要的方法有:</p>
<ul>
<li>Object attach(Object obj) 为当前的SelectionKey关联一个对象</li>
<li>Object attachment() 获取当前SelectionKey关联的对象</li>
<li>SelectableChannel channel() 返回与当前SelectionKey关联的SelectedChannel对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> NIO_BUFFER_LIMIT=<span class="number">8</span>*<span class="number">1024</span>;<span class="comment">//chunk大小为8kb</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">channelWrite</span><span class="params">(WritableByteChannel channel,ByteBuffer buffer)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果缓冲区中的数据小于8kb,则直接写到Channel,否则以Chunk为单位写入</span></span><br><span class="line">    <span class="keyword">return</span> (buffer.remaining()&lt;=NIO_BUFFER_LIMIT)?channel.write(buffer):channelIO(<span class="keyword">null</span>,channel,buffer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">channelIO</span><span class="params">(ReadableByteChannel readCh,WritableByteChannel writeCh,ByteBuffer buf)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> originalLimit=buf.limit(); </span><br><span class="line">    <span class="keyword">int</span> initialRemaining=buf.remaining();</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(buf.remaining()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            init ioSize=Math.min(buf.remaining(),NIO_BUFFER_LIMIT);</span><br><span class="line">            buf.limit(buf.position()+ioSize);</span><br><span class="line">            ret=(readCh==<span class="keyword">null</span>)?writeCh.write(buf):readCh.read(buf);</span><br><span class="line">            <span class="comment">//非阻塞模式下,write或read方法函数对应的网络缓冲区满后,会直接返回,返回值为实际写入或者读取的数据</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(ret&lt;ioSize)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            buf.limit(originalLimit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> nBytes=initialRemaining-buf.remaining();</span><br><span class="line">    <span class="keyword">return</span> (nBytes&gt;<span class="number">0</span>)?nBytes:ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">echoServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> InetSocketAddress address;</span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel serverSocketChannel;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initSelector</span><span class="params">(String host,<span class="keyword">int</span> port,<span class="keyword">int</span> backlogLength)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        address=<span class="keyword">new</span> InetSocketAddress(host,port);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个ServerSocketChannel并设置为非阻塞模式</span></span><br><span class="line">        serverSocketChannel=ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将Server Socket绑定到address地址上,并设置监听长度</span></span><br><span class="line">        serverSocketChannel.socket().bind(address,backlogLength);</span><br><span class="line">        selector=Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向Selector注册ServerSocketChannel,注册事件为SelectionKey.OP_ACCEPT</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAccept</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        ServerSocketChannel serverSocketChannel1= (ServerSocketChannel) key.channel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接受连接请求,并将其设置为非阻塞模式</span></span><br><span class="line">        SocketChannel socketChannel=serverSocketChannel1.accept();</span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//将新的SocketChannel注册到Selector中,一旦有需要读或写的数据,就会通知相应的程序</span></span><br><span class="line">        SelectionKey clientKey=socketChannel.register(selector,SelectionKey.OP_READ);</span><br><span class="line">        ByteBuffer byteBuffer=ByteBuffer.allocate(<span class="number">8192</span>);</span><br><span class="line">        clientKey.attach(byteBuffer);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        SocketChannel socketChannel= (SocketChannel) key.channel();</span><br><span class="line">        ByteBuffer byteBuffer= (ByteBuffer) key.attachment();</span><br><span class="line">        <span class="keyword">int</span> numRead=socketChannel.read(byteBuffer);</span><br><span class="line">        <span class="keyword">if</span>(numRead&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            key.interestOps(SelectionKey.OP_WRITE);<span class="comment">//切换为写请求</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(SelectionKey key)</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        SocketChannel socketChannel= (SocketChannel) key.channel();</span><br><span class="line">        ByteBuffer byteBuffer= (ByteBuffer) key.attachment();</span><br><span class="line">        socketChannel.write(byteBuffer);</span><br><span class="line">        <span class="keyword">if</span>(byteBuffer.remaining()==<span class="number">0</span>)&#123;<span class="comment">//写完成后,切换为读请求</span></span><br><span class="line">            byteBuffer.clear();</span><br><span class="line">            key.interestOps(SelectionKey.OP_READ);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String host,<span class="keyword">int</span> port,<span class="keyword">int</span> backlogLength)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        initSelector(host,port,backlogLength);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            SelectionKey key=<span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                selector.select();<span class="comment">//处于阻塞状态,直到有新事件发生</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; iter=selector.selectedKeys().iterator();</span><br><span class="line">                <span class="keyword">while</span> (iter.hasNext())&#123;</span><br><span class="line">                    key=iter.next();</span><br><span class="line">                    iter.remove();</span><br><span class="line">                    <span class="keyword">if</span>(!key.isValid())</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">                        doAccept(key);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                        receive(key);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isWritable())&#123;</span><br><span class="line">                        send(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                    key=<span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Hadoop_RPC框架的使用">Hadoop RPC框架的使用</h2><p>Hadoop RPC主要对外提供了两种接口:</p>
<ul>
<li>public static VersionedProtocol getProxy/waitForProxy():用于构造一个客户端代理对象(该对象实现了某个协议),用于向服务器端发送RPC请求.</li>
<li>public static Server getServer():为某个协议(实际上是Java接口)实例构造一个服务器对象,用于处理客户端发送的请求.</li>
</ul>
<p>第一步:定义RPC接口.RPC协议是客户端与服务端间的通信接口,它定义了服务器端对外提供的服务接口.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里定义了一个通信接口,这个接口声明了两个方法,我们所定义的Hadoop RPC接口都要继承VersionedProtocol</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClientProtocol</span> <span class="keyword">extends</span> <span class="title">VersionedProtocol</span></span>&#123;</span><br><span class="line">	<span class="comment">//默认情况下,不同版本号的RPC Client和Server间无法互相通信</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> versionID=<span class="number">1L</span>;</span><br><span class="line">    <span class="function">PersonWritable <span class="title">getPersonInfo</span><span class="params">(String name)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNewPersonInfo</span><span class="params">(PersonWritable person)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二步:实现RPC协议.Hadoop RPC接口是一个Java接口,用户需要实现该接口,该接口实现类就是实际处理客户端请求的服务类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientProtocolImpl</span> <span class="keyword">implements</span> <span class="title">ClientProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,PersonWritable&gt; persons=<span class="keyword">new</span> HashMap&lt;String, PersonWritable&gt;();</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PersonWritable <span class="title">getPersonInfo</span><span class="params">(String name)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> persons.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNewPersonInfo</span><span class="params">(PersonWritable person)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        persons.put(person.getName(), person);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getProtocolVersion</span><span class="params">(String s, <span class="keyword">long</span> l)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> versionID;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三步:构造并启动RPC Server(RPC服务端).直接使用静态方法getServer()构造一个RPC Server,并调用函数start()启动该Server:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">	<span class="comment">//传入参数有处理客户端请求的服务实例,服务端绑定的IP地址和端口号,服务端处理请求的线程数目</span></span><br><span class="line">    Server server=RPC.getServer(<span class="keyword">new</span> ClientProtocolImpl(), <span class="string">"127.0.0.1"</span>, <span class="number">1528</span>, <span class="number">4</span>, <span class="keyword">false</span>, <span class="keyword">new</span> Configuration());</span><br><span class="line">    server.start();</span><br><span class="line">    <span class="comment">//启动后服务器处于监听状态,等待客户端请求到达</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第四步:构造RPC Client(RPC客户端),并发送RPC请求.使用静态方法getProxy()构造客户端代理对象,直接通过代理对象调用远程端方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClientProtocol proxy=(ClientProtocol)RPC.getProxy(ClientProtocol.class, ClientProtocol.versionID,<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>,<span class="number">1528</span>), <span class="keyword">new</span> Configuration());</span><br><span class="line">proxy.addNewPersonInfo(<span class="keyword">new</span> PersonWritable(<span class="string">"Dong"</span>,<span class="number">21</span>,<span class="string">"Programmer"</span>));</span><br><span class="line">System.out.println(proxy.getPersonInfo(<span class="string">"Dong"</span>));</span><br></pre></td></tr></table></figure>
<p>如下的动态图展示Hadoop RPC的使用,我们在两个IDE中分别启动服务端和客户端,其中服务端对象维护着一个map对象,在另一个IDE中启动了两个客户端去访问这个服务端对象,可以看到,客户端可以正常访问服务端对象,并且在客户端访问退出后,服务端抛出了远程主机关闭的异常.<br><img src="http://7xonn1.com1.z0.glb.clouddn.com/hadoop-rpc-test.gif" alt="Use Hadoop RPC"></p>
<h2 id="剖析Hadoop_RPC框架实现机制">剖析Hadoop RPC框架实现机制</h2><h3 id="客户端入口">客户端入口</h3><p>可以从下图看到,客户端入口的方法是RPC.getProxy这个静态方法,该方法接受4个参数分别是:</p>
<ul>
<li>Class&lt;? extends VersionedProtocol&gt; protocol 客户端代理对象和服务端的服务类对象都要实现的接口的类对象,也就是客户端代理与服务端之间的通信协议</li>
<li>long clientVersion  客户端代理对象实现该协议的版本号,客户端代理和服务类版本号需要一致,不然将抛出异常并结束调用</li>
<li>InetSocketAddress addr 服务器地址包含了IP地址和端口号</li>
<li>Configuration conf 配置参数信息</li>
</ul>
<p>并且可选两个参数:</p>
<ul>
<li>SocketFactory factory 套接字工厂,如果创建客户端代理过程中没有特别指定该参数,创建的所有客户端代理都将使用同一个工厂实例创建套接字</li>
<li>int rpcTimeOut rpc超时时间,底层套接字通信设置的参数,默认为0</li>
</ul>
<p>调用该方法后将使用Java动态代理为客户端代理创建一个Java动态代理对象,从下图可以看出,实际处理客户端代理请求的对象是RPC.Invoker类,这个类实现了InvocationHandler接口,并实现了invoke方法,在该方法中接受客户端代理请求并进行响应.</p>
<p>Invoker的构造函数接受了创建客户端代理时传入的所有参数,并且可以看到有一个UserGroupInformation的参数,由于不考虑在通信过程中的安全认证和身份信息方面的问题,所以这个参数为null.Invoker接受这些参数主要用于构建两个实例,一个是ConnectionId,这个实例主要是在Invoker内部维护对服务器的连接信息,每个客户端代理都会维护一个ConnectionId实例,除了该实例外,每个客户端代理还需要在Invoker对象中维护一个Client对象,这个对象是使用套接字工厂实例从RPC.CLIENTS这个全局静态实例获取的,也就是说在默认情况下所有的客户端代理对象将引用同一个客户端对象.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Invoker类实现了InvocationHandler接口,将在invoke方法中响应客户端代理的请求</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Invoker</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> ConnectionId remoteId; <span class="comment">//这个类包含了与服务器端进行通信的相关参数</span></span><br><span class="line">        <span class="keyword">private</span> Client client; <span class="comment">//客户端对象</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> isClosed = <span class="keyword">false</span>; <span class="comment">//是否关闭客户端代理的请求服务</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Invoker</span><span class="params">(Class&lt;? extends VersionedProtocol&gt; protocol, InetSocketAddress address, UserGroupInformation ticket, Configuration conf, SocketFactory factory, <span class="keyword">int</span> rpcTimeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.remoteId = ConnectionId.getConnectionId(address, protocol, ticket, rpcTimeout, conf);</span><br><span class="line">            <span class="keyword">this</span>.client = RPC.CLIENTS.getClient(conf, factory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>ConnectId类是Client类的一个静态内部类,这个类保存了与服务器进行连接的所需要的参数,包括</p>
<ul>
<li>InetAddress address 服务器地址,包括了IP和端口号,是连接服务器所需要的最基本的信息</li>
<li>Class&lt;?&gt; protocol 协议的类对象</li>
<li>rpcTimeOut rpc超时时间 默认为0</li>
<li>maxIdleTime 最大空闲时间 默认为 1000 从配置参数获取</li>
<li>maxRetires 最大重试时间 默认为10 从配置参数获取</li>
<li>boolean tcpNodelay 这是套接字参数,见上文从配置参数获取 默认为true</li>
<li>int pingInterval ping间隔 默认为0 从配置参数获取</li>
</ul>
<p>在构造过程中将调用RPC.CLIENTS.getClient方法获取一个客户端对象.CLIENT静态实例是一个ClientCache类对象,由于客户端代理会竞争访问这个实例,所以这个类是线程安全类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientCache</span> </span>&#123;</span><br><span class="line">     <span class="comment">//其内部维护了套接字工厂实例和客户端对象一一对应的关系</span></span><br><span class="line">     <span class="keyword">private</span> Map&lt;SocketFactory, Client&gt; clients;</span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="title">ClientCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.clients = <span class="keyword">new</span> HashMap();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//获取客户端对象的方法是一个静态方法,如果传入了套接字工厂实例对应的客户端对象存在,则直接返回并将客户端对象的引用值增一否则创建对应的工厂实例的客户端对象,并进行保存.</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> Client <span class="title">getClient</span><span class="params">(Configuration conf, SocketFactory factory)</span> </span>&#123;</span><br><span class="line">         Client client = (Client)<span class="keyword">this</span>.clients.get(factory);</span><br><span class="line">         <span class="keyword">if</span>(client == <span class="keyword">null</span>) &#123;</span><br><span class="line">             client = <span class="keyword">new</span> Client(ObjectWritable.class, conf, factory);</span><br><span class="line">             <span class="keyword">this</span>.clients.put(factory, client);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             client.incCount();</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> client;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>客户端对象类Client是非常重要也是非常复杂的一个类,在该类中将维护多个客户端代理与其对应的服务端的通信过程.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">     <span class="comment">//维护了ConnectionId和Connection一一对应的关系,由于ConnectionId每个客户端代理都会维护一个实例,所以Client对象将在其内部为每个客户端代理维护一个Connection实例,这是一个线程对象,是真正实现客户端代理请求和响应的地方</span></span><br><span class="line">     <span class="keyword">private</span> Hashtable&lt;Client.ConnectionId, Client.Connection&gt; connections;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//这是ObjectWritable对象,涉及了Hadoop序列化机制,用于将本地对象进行序列号用于网络传输</span></span><br><span class="line">     <span class="keyword">private</span> Class&lt;? extends Writable&gt; valueClass;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> counter;</span><br><span class="line">     <span class="comment">//客户对象的运行标志</span></span><br><span class="line">     <span class="keyword">private</span> AtomicBoolean running;</span><br><span class="line">     <span class="comment">//配置信息</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> Configuration conf;</span><br><span class="line">     <span class="comment">//套接字工厂,用于创建套接字</span></span><br><span class="line">     <span class="keyword">private</span> SocketFactory socketFactory;</span><br><span class="line">     <span class="comment">//表示该Client对象被客户端代理的引用计数</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> refCount;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PING_INTERVAL_NAME = <span class="string">"ipc.ping.interval"</span>;</span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_PING_INTERVAL = <span class="number">60000</span>;</span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PING_CALL_ID = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此客户端代理对象创建完成,可以为客户端提供服务.</p>
<p><img src="http://7xonn1.com1.z0.glb.clouddn.com/hadoop_rpc.jpg" alt="Hadoop RPC"></p>
<p>接下来分析Invoker.invoke方法,这里实现接受客户端代理请求并进行响应.invoke方法接受三个参数:</p>
<ul>
<li>Object proxy 是客户端代理对象(将被忽略)</li>
<li>Method method 代表客户端请求的方法</li>
<li>Object[] args 方法请求参数的对象列表</li>
</ul>
<p>由于客户端创建代理时只会创建对应的客户端对象和含有服务器连接的信息对象,并未开始向服务器发起连接,也未没有任何实际处理和响应请求的线程产生,所以在后续在客户端代理对象上发起请求时,这些操作将会发生.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//invoke方法只有短短的两条语句,但是涉及了三个类,这几个类也是Hadoop RPC实现最核心的部分</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            ObjectWritable value = (ObjectWritable)<span class="keyword">this</span>.client.call(<span class="keyword">new</span> RPC.Invocation(method, args), <span class="keyword">this</span>.remoteId);</span><br><span class="line">            <span class="keyword">return</span> value.get();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>首先是RPC.Invocation这个类,这个类继承了Writable接口,是一个可序列化的类,这个类打包了客户端代理请求的相关信息(包括方法名和参数对象列表),通过将这个对象打包并传输到服务端,服务端通过解析这个对象,获取相关信息,并通过反射机制实现调用并将结果返回给客户端.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个类存储了请求方法的名字,请求参数的对象列表,请求参数的对象的类对象列表,这里涉及了Hadoop序列化的相关知识,将在另外一篇博客说明.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Invocation</span> <span class="keyword">implements</span> <span class="title">Writable</span>, <span class="title">Configurable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String methodName;</span><br><span class="line">        <span class="keyword">private</span> Class[] parameterClasses;</span><br><span class="line">        <span class="keyword">private</span> Object[] parameters;</span><br><span class="line">        <span class="keyword">private</span> Configuration conf;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Invocation</span><span class="params">(Method method, Object[] parameters)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.methodName = method.getName();</span><br><span class="line">            <span class="keyword">this</span>.parameterClasses = method.getParameterTypes();</span><br><span class="line">            <span class="keyword">this</span>.parameters = parameters;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFields</span><span class="params">(DataInput in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.methodName = UTF8.readString(in);</span><br><span class="line">            <span class="keyword">this</span>.parameters = <span class="keyword">new</span> Object[in.readInt()];</span><br><span class="line">            <span class="keyword">this</span>.parameterClasses = <span class="keyword">new</span> Class[<span class="keyword">this</span>.parameters.length];</span><br><span class="line">            ObjectWritable objectWritable = <span class="keyword">new</span> ObjectWritable();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.parameters.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">this</span>.parameters[i] = ObjectWritable.readObject(in, objectWritable, <span class="keyword">this</span>.conf);</span><br><span class="line">                <span class="keyword">this</span>.parameterClasses[i] = objectWritable.getDeclaredClass();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(DataOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            UTF8.writeString(out, <span class="keyword">this</span>.methodName);</span><br><span class="line">            out.writeInt(<span class="keyword">this</span>.parameterClasses.length);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.parameterClasses.length; ++i) &#123;</span><br><span class="line">                ObjectWritable.writeObject(out, <span class="keyword">this</span>.parameters[i], <span class="keyword">this</span>.parameterClasses[i], <span class="keyword">this</span>.conf);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>下图展现了Invocation类型对象的序列化和反序列化机制<br><img src="http://7xonn1.com1.z0.glb.clouddn.com/Invocation%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96.png" alt="Invocation Class Serialization And Deserialization"><br>接下来详细分析Client类的call方法,在call方法中,Invocation对象又被封装入Client.Call对象中,Call类是一个线程安全类,客户端代理会等待该对象的done标志为true,在等待期间,客户端代理可被中断,在done标志为true时,客户端代理会检查该对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Writable <span class="title">call</span><span class="params">(Writable param, Client.ConnectionId remoteId)</span> <span class="keyword">throws</span> InterruptedException, IOException </span>&#123;</span><br><span class="line">     <span class="comment">//请求体对象被封装入Call对象中</span></span><br><span class="line">     Client.Call call = <span class="keyword">new</span> Client.Call(param);</span><br><span class="line">     Client.Connection connection = <span class="keyword">this</span>.getConnection(remoteId, call);</span><br><span class="line">     connection.sendParam(call);</span><br><span class="line">     <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">     <span class="keyword">synchronized</span>(call) &#123;</span><br><span class="line">         <span class="keyword">while</span>(!call.done) &#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 call.wait();</span><br><span class="line">             &#125; <span class="keyword">catch</span> (InterruptedException var9) &#123;</span><br><span class="line">                 interrupted = <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span>(interrupted) &#123;</span><br><span class="line">             Thread.currentThread().interrupt();</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span>(call.error != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">if</span>(call.error <span class="keyword">instanceof</span> RemoteException) &#123;</span><br><span class="line">                 call.error.fillInStackTrace();</span><br><span class="line">                 <span class="keyword">throw</span> call.error;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="keyword">throw</span> <span class="keyword">this</span>.wrapException(connection.getRemoteAddress(), call.error);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">return</span> call.value;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://7xonn1.com1.z0.glb.clouddn.com/hadoop_rpc_2.jpg" alt="Hadoop RPC"></p>
<p>Connection类是一个线程类,维护着客户端代理和服务端的一个通信连接.通信连接信息包括:</p>
<ul>
<li>InetAddress address 服务器地址,包括了IP和端口号,是连接服务器所需要的最基本的信息</li>
<li>ConnectionHeader header 连接的协议头</li>
<li>Client.ConnectionId remoteId 这个对象保存了与服务器进行连接的所需要的参数</li>
<li>AuthMethod authMethod 方法请求认证方式</li>
<li>Socket socket = null 客户端套接字</li>
<li>DataInputStream in 输入流</li>
<li>DataOutputStream out 输出流</li>
<li>int rpcTimeout rpc超时时间</li>
<li></li>
</ul>
<h3 id="服务端入口">服务端入口</h3>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/12/10/classic_search_algorithm/" title="经典的查找算法" itemprop="url">经典的查找算法</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="rookiedong" target="_blank" itemprop="author">rookiedong</a>
		
  <p class="article-time">
    <time datetime="2015-12-10T05:31:14.000Z" itemprop="datePublished"> 发表于 2015-12-10</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="折半查找算法">折半查找算法</h2><p>   折半查找算法(half-interval search),也被称为二分查找算法,是在一个有序数组中查找一个特定元素的算法.搜索过程从数组的中间元素开始,如果中间元素正好是要查找的的元素,则搜索过程结束.如果某一个特定元素大于或小于中间元素,则在数组大于或小于中间元素的那一半查找.而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到.这种搜索算法每一次比较都使搜索范围缩小一半.可以证明,对于一个大小为N的有序数组中查找某个特定元素最多的查找次数不会超过logN+1.由于底层存储结构为一个有序数组,所以插入一个特定元素平均需要移动N个元素.</p>
<p>   下图显示在一个有序数组中查找某一个特定元素的折半查找算法的查找过程<br>     <img src="http://7xonn1.com1.z0.glb.clouddn.com/bsa.png?imageView/2/w/519/q/80" alt="Half Interval Search Produce"></p>
<h3 id="复杂度分析">复杂度分析</h3><p>   可以看出折半查找算法在一个有序数组中具有最优的查找效率和空间需求,而对于插入操作则是非常慢的.</p>
<table>
<thead>
<tr>
<th>算法</th>
<th>最差情况下查找成本</th>
<th>最差情况下插入成本</th>
<th>平均情况下查找成本</th>
<th>平均情况下插入成本</th>
</tr>
</thead>
<tbody>
<tr>
<td>折半查找算法</td>
<td>On(lgN)</td>
<td>O(N)</td>
<td>On(lgN)</td>
<td>O(N)</td>
</tr>
</tbody>
</table>
<h2 id="二叉查找树">二叉查找树</h2><p>二叉查找树(Binary Search Tree),也被称为二叉搜索树,有序二叉树,是指一棵空树或者具有如下性质的二叉树:</p>
<ul>
<li>若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值</li>
<li>任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值</li>
<li>任意节点的左、右子树也分别为二叉查找树</li>
<li>没有键值相等的节点</li>
</ul>
<p>下图显示一棵典型的二叉查找树结构<br><img src="http://7xonn1.com1.z0.glb.clouddn.com/bst.png?imageView/2/w/519/q/80" alt="Binary Search Tree Structure"></p>
<p>二叉查找树相比于其他数据结构的优势在于其查找,插入的时间复杂度较低,为O(logN).通常采用二叉链表作为二叉查找树的存储结构,中序遍历二叉树可以得到一个关键字的有序序列.使用二叉查找树的算法的运行时间取决于树的形状,而树的形状又取决于键被插入的顺序.最好的情况下,一颗含有N个结点的树是完全平衡的,每条空链和根结点的距离都是~logN.最坏情况下,搜索路径上可能有N个节点.</p>
<p>下图显示二叉查找数的可能形状<br><img src="http://7xonn1.com1.z0.glb.clouddn.com/bst_shape.png?imageView/2/w/519/q/80" alt="Probably Shape About BST"></p>
<h3 id="复杂度分析-1">复杂度分析</h3><p>可以看出二叉查找树实现简单,但是没有性能上界的保证,链表需要额外空间</p>
<table>
<thead>
<tr>
<th>算法</th>
<th>最差情况下查找成本</th>
<th>最差情况下插入成本</th>
<th>平均情况下查找成本</th>
<th>平均情况下插入成本</th>
</tr>
</thead>
<tbody>
<tr>
<td>二叉查找树</td>
<td>On(N)</td>
<td>O(N)</td>
<td>On(lgN)</td>
<td>O(lgN)</td>
</tr>
</tbody>
</table>
<h3 id="插入操作">插入操作</h3><p>向一个二叉查找树b中插入一个节点s的算法,过程为:</p>
<ol>
<li>若b是空树，则将s所指结点作为根节点插入,否则：</li>
<li>若s-&gt;data等于b的根节点的数据域之值,则返回,否则：</li>
<li>若s-&gt;data小于b的根节点的数据域之值,则把s所指节点插入到左子树中,否则:</li>
<li>把s所指节点插入到右子树中.(新插入节点总是叶子节点)</li>
</ol>
<p>下图显示二叉查找树的插入操作<br><img src="http://7xonn1.com1.z0.glb.clouddn.com/bst_find.png?imageView/2/w/519/q/80" alt="Insert On BST"></p>
<h3 id="查找操作">查找操作</h3><p>在二叉查找树b中查找x的过程为:</p>
<ol>
<li>若b是空树,则搜索失败,否则:</li>
<li>若x等于b的根节点的数据域之值,则查找成功;否则:</li>
<li>若x小于b的根节点的数据域之值,则搜索左子树;否则:</li>
<li>查找右子树。</li>
</ol>
<p>下图显示二叉查找数的查找操作<br><img src="http://7xonn1.com1.z0.glb.clouddn.com/insert_on_bst.png?imageView/2/w/519/q/80" alt="Search On BST"></p>
<h3 id="删除操作">删除操作</h3><p>删除操作要分为三种情况进行讨论:</p>
<ol>
<li>如果待删除节点是叶子节点,则可以直接删除</li>
<li>如果待删除节点有一个分支不为空,则将该分支直接继承给待删除节点的父节点</li>
<li>如果待删除节点两个分支都不为空,则有两种方法可以处理,一种是查找待删除节点左分支最大的节点,如果该节点有左分支,则首先将该节点的左分支继承给其父节点,然后将待删除节点的位置替换为该节点.第二种情况是查找待删除节点右分支最小的节点,如果该节点有右分支,则首先将该节点的右分支继承给其父节点,然后将待删除节点的位置替换为该节点.</li>
</ol>
<p>下图显示二叉查找数的删除操作<br><img src="http://7xonn1.com1.z0.glb.clouddn.com/delete_on_bst.png?imageView/2/w/519/q/80" alt="Delete On BST"></p>
<h2 id="AVL树">AVL树</h2><p>AVL树是一种自平衡二叉查找树.在AVL树中任何节点的两个子树最大的高度差不超过1,所以AVL数也是一种高度平衡的树.在其上进行查找,删除和插入的操作最坏和平均情况下的时间复杂度都不会超过O(lgN).在树上进行插入和删除操作可能需要通过一次或多次的树旋转操作重新平衡该树.节点的平衡因子指的是其左子树高度减去右子树高度,在AVL树中该值取值范围为-1,0和1.当该值为2时,树就是非平衡的,需要通过树旋转来重新平衡.平衡因子通常存储于节点中.</p>
<h3 id="树旋转">树旋转</h3><p>不平衡情况分为四种,其中左左和右右情况可以通过一次右旋转或左旋转来达到重新平衡</p>
<p>下图显示左左和右右情况下进行树的平衡操作<br><img src="http://7xonn1.com1.z0.glb.clouddn.com/ll_rr.png?imageView/2/w/519/q/80" alt="Rebalance BST When BST Is In Left-Left Or Right-Right Situation"></p>
<p>而左右情况通过一次左旋和一次右旋,右左情况通过一次右旋和一次左旋来达到重新平衡</p>
<p>下图显示左右和右左情况下进行树的平衡操作<br><img src="http://7xonn1.com1.z0.glb.clouddn.com/rl_lr1.png?imageView/2/w/519/q/80" alt="Rebalance BST When BST Is In Left-Right Or Right-Left Situation"></p>
<h3 id="插入操作-1">插入操作</h3><p>由于AVL树也是一颗二叉查找树,向AVL树插入节点时,插入节点的父节点要么是叶子节点或者父节点其左分支或右分支只有一个节点.所以对于存在左或右分支的被插入节点的父节点,只需修改父节点的平衡因子为0并且修改被插入的父节点到根节点的节点数即可.而对于被插入节点的父节点为叶子节点的情况,则从被插入父节点开始到根节点为止,依次检查各个节点的左右分支是否平衡,对于不平衡的节点依次进行树旋转.</p>
<p>下图显示对于AVL树进行插入的操作<br><img src="http://7xonn1.com1.z0.glb.clouddn.com/avl_put.png?imageView/2/w/519/q/80" alt="Insert On AVL Tree"></p>
<h3 id="删除操作-1">删除操作</h3><p>如果被删除节点为叶子节点或只有左或右分支,则考虑其父节点,如果父节点先前平衡因子为0,则只需调整其平衡因子.如果父节点平衡因子为1且删除其右分支节点或相反,则父节点发生失衡,因此从父节点开始向上调整失衡的节点.如果父节点平衡因子为1且删除其左分支节点或相反,则父节点平衡因子变为0,高度发生改变,则从父节点的父节点开始向上调整失衡节点</p>
<p><img src="http://7xonn1.com1.z0.glb.clouddn.com/delete1.png?imageView/2/w/519/q/80" alt="Delete On AVL Tree When Deleted Node Is Leaf Or Has Only One Branch"></p>
<p>如果被删除节点左右分支都不为空,则首先要判断被删节点的平衡因子,如果平衡因子为1,则从左分支获取最大节点替换被删节点,且被删节点左分支要进行树旋转对其进行重平衡,之后替换被删节点后,也需要对整颗树进行重平衡.如果平衡因子为-1,则从右分支获取最小节点替换被删节点,如果为0,则都行.</p>
<p><img src="http://7xonn1.com1.z0.glb.clouddn.com/delete_on_avl.png?imageView/2/w/519/q/80" alt="Delete On AVL Tree When Two Branches Of Deleted Node Are Neither None"></p>
<h3 id="复杂度分析-2">复杂度分析</h3><table>
<thead>
<tr>
<th>算法</th>
<th>最差情况下查找成本</th>
<th>最差情况下插入成本</th>
<th>平均情况下查找成本</th>
<th>平均情况下插入成本</th>
</tr>
</thead>
<tbody>
<tr>
<td>AVL树</td>
<td>On(lgN)</td>
<td>O(lgN)</td>
<td>On(lgN)</td>
<td>O(lgN)</td>
</tr>
</tbody>
</table>
<h2 id="红黑树">红黑树</h2><p>红黑树的定义是一颗具有红黑链接并且满足如下条件的二叉查找树:</p>
<ol>
<li>红链接均为左链接</li>
<li>没有任何一个节点同时和和两条红链接相连</li>
<li>该树是完美黑色平衡,即任意的空链接到根节点的路径上黑链接数量相同</li>
<li>根节点为黑色节点</li>
</ol>
<p>同时节点使用父节点指向自己的链接的颜色来表示该节点的颜色,链接为红则为红节点,链接为黑则为黑节点,节点颜色保存在节点中.</p>
<p>下图展现一颗典型的红黑树结构<br><img src="http://7xonn1.com1.z0.glb.clouddn.com/rbtree.png?imageView/2/w/519/q/80" alt="Red Black Tree Structure"></p>
<h3 id="旋转">旋转</h3><p>我们在操作红黑树的过程中可能会出现红色的右链接或者出现两条连续的红链接,但通过旋转这些情况都会被修复.对红色的右链接需要被转化为左链接,称为左旋转.而对于相反的过程称为右旋转.</p>
<p><img src="http://7xonn1.com1.z0.glb.clouddn.com/rotate_on_rbtree.png?imageView/2/w/519/q/80" alt="Left-Rotation And Right-Rotation On Red Black Tree"></p>
<h3 id="插入">插入</h3><p>对于插入操作,首先要保证树的有序性和完美平衡性,所以要以二叉查找树方式插入节点,插入节点后为了保持树的完美平衡性,则需要以红色右链接或红色左链接方式链接插入的节点,插入后如果存在红色右链接或连续红色链接,则通过旋转方式来修复.</p>
<p>对于向只含有一个根节点的红黑树插入一个节点,比较插入节点和根节点的键,如果小于则根节点以红色左链接链接插入节点.如果大于则根节点以红色右链接链接插入节点,且对红色右链接进行一次左旋转,使红色右链接变为红色左链接.对于从树底部插入节点情情况,由于为了保持树的完美平衡性,需要以红色链接方式插入节点,如果被插入节点为黑色节点且插入左分支,则直接以红色左链接方式插入.如果插入右分支,则以红色右链接方式插入且做一次左旋转修复.</p>
<p><img src="http://7xonn1.com1.z0.glb.clouddn.com/insert_1.png?imageView/2/w/519/q/80" alt="Insert On Red Black Tree When Inserted Node Is A Root Or A Black Node And Is Also A Leaf"></p>
<p>被插入节点如果其左分支为红节点,则插入后被插入节点将有两条红链接,可以直接将这两条红链接变为黑链接解决.被插入节点为红节点,则如果插入红节点左分支,则对指向被插入节点的红色左链接进行右旋,之后将两条红链接变为黑链接解决并且指向父节点的黑链接需要变换为红链接.如果插入红节点右分支,则对被插入节点的红链接进行左旋变为左链接,之后对指向被插入节点的红链接进行右旋,并将两条红链接变为黑链接解决并且指向父节点的黑链接需要变换为红链接.</p>
<p><img src="http://7xonn1.com1.z0.glb.clouddn.com/insert_4.png?imageView/2/w/519/q/80" alt="Insert On Red Black Tree When Inserted Node Is A Red Node Or LeftChild Is A Red Node"></p>
<p>在上述插入操作中,有可能使红黑树中已有的黑节点变换为红节点,这就可能出现红色右链接或连续的红链接,这时需要递归的处理这些情况.</p>
<p><img src="http://7xonn1.com1.z0.glb.clouddn.com/rbt_rotation.png?imageView/2/w/519/q/80" alt="递归的处理链接向上转移"></p>
<h3 id="删除">删除</h3><h3 id="删除最小键">删除最小键</h3><h3 id="复杂度分析-3">复杂度分析</h3><table>
<thead>
<tr>
<th>算法</th>
<th>最差情况下查找成本</th>
<th>最差情况下插入成本</th>
<th>平均情况下查找成本</th>
<th>平均情况下插入成本</th>
</tr>
</thead>
<tbody>
<tr>
<td>红黑树</td>
<td>On(lgN)</td>
<td>O(lgN)</td>
<td>On(lgN)</td>
<td>O(lgN)</td>
</tr>
</tbody>
</table>
<h2 id="散列表">散列表</h2><h2 id="跳表">跳表</h2><h2 id="参考">参考</h2><p><a href="http://7xp4g9.com1.z0.glb.clouddn.com/%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89.html" target="_blank" rel="external">接口定义</a><br><a href="http://7xoeea.com1.z0.glb.clouddn.com/python%E5%AE%9E%E7%8E%B0%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95.html" target="_blank" rel="external">折半查找算法python实现</a><br><a href="http://7xoeea.com1.z0.glb.clouddn.com/python%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91.html" target="_blank" rel="external">二叉查找树python实现</a><br><a href="http://7xoeea.com1.z0.glb.clouddn.com/python%E5%AE%9E%E7%8E%B0AVL%E6%A0%91.html" target="_blank" rel="external">AVL树python实现</a><br><a href="http://7xoeea.com1.z0.glb.clouddn.com/%E7%BA%A2%E9%BB%91%E6%A0%91python%E9%83%A8%E5%88%86%E5%AE%9E%E7%8E%B0.html" target="_blank" rel="external">红黑树python部分实现</a></p>
<h2 id="引用">引用</h2><p><a href="http://zh.wikipedia.net.ru/wiki/%E6%8A%98%E5%8D%8A%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95" target="_blank" rel="external">折半搜索算法</a><br><a href="http://zh.wikipedia.net.ru/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9" target="_blank" rel="external">二叉查找树</a><br><a href="http://zh.wikipedia.net.ru/wiki/AVL%E6%A0%91" target="_blank" rel="external">AVL树</a><br><a href="http://zh.wikipedia.net.ru/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91" target="_blank" rel="external">红黑树</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/12/10/io/" title="Java I/O流类型" itemprop="url">Java I/O流类型</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="rookiedong" target="_blank" itemprop="author">rookiedong</a>
		
  <p class="article-time">
    <time datetime="2015-12-10T03:17:09.000Z" itemprop="datePublished"> 发表于 2015-12-10</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="装饰者模式">装饰者模式</h2><h3 id="装饰者模式定义">装饰者模式定义</h3><p>装饰者模式是一个设计模式,装饰者模式可以不修改任何底层代码的情况下,给对象赋予新的职责,其定义是:</p>
<ul>
<li>装饰者模式动态地将责任附加到对象上.若要扩展功能,装饰者提供了比继承更有弹性的替代方案.</li>
</ul>
<p>装饰者模式体现了面向对象中一个重要的设计原则:</p>
<ul>
<li>开放-关闭原则(类应该对扩展开放,对修改关闭)</li>
</ul>
<p>面向对象中一个重要目标是类容易扩展,在不修改现有代码情况下,就可以搭配新的行为,如果能实现这样的目标,就能弹性应对改变,并且可以接受新的功能来应对改变的需求.</p>
<p>下图展现了装饰者模式的类图<br><img src="http://7xonn1.com1.z0.glb.clouddn.com/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F.png" alt="Decorator Pattern Diagram"></p>
<h3 id="装饰者模式例子">装饰者模式例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Beverage类是一个代表饮料的类,相当于抽象的Componet类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Beverage</span></span>&#123;</span><br><span class="line">    String description=<span class="string">"Unknown Beverage"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//HouseBlend类是一个代表某种具体饮料的类,相当于具体的Componet类,继承于抽象的Componet类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HouseBlend</span> <span class="keyword">extends</span> <span class="title">Beverage</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HouseBlend</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.description=<span class="string">"House Blend"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.99</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//DarkRoast类是一个代表某种具体饮料的类,相当于具体的Componet类,继承于抽象的Componet类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DarkRoast</span> <span class="keyword">extends</span> <span class="title">Beverage</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DarkRoast</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.description=<span class="string">"Dark Roast"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2.12</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Espresso类是一个代表某种具体饮料的类,相当于具体的Componet类,继承于抽象的Componet类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Espresso</span> <span class="keyword">extends</span> <span class="title">Beverage</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Espresso</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.description=<span class="string">"Espresso"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2.34</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Decaf类是一个代表某种具体饮料的类,相当于具体的Componet类,继承于抽象的Componet类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decaf</span> <span class="keyword">extends</span> <span class="title">Beverage</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decaf</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.description=<span class="string">"Decaf"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.99</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//每个装饰者都包装了一个组件,也就是说每个装饰器都有一个引用指向了一个具体的组件,这里定义了一个抽象的装饰器类,每个具体的装饰器类都要继承这个抽象的装饰器类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CondimentDecorator</span> <span class="keyword">extends</span> <span class="title">Beverage</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span>  String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Mocha类是一个具体的装饰器类,其继承了抽象的装饰器类,并且引用了一个具体的组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mocha</span> <span class="keyword">extends</span> <span class="title">CondimentDecorator</span></span>&#123;</span><br><span class="line">    Beverage beverage;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mocha</span><span class="params">(Beverage beverage)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beverage=beverage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.getDescription()+<span class="string">", Mocha"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.20</span>+beverage.cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Milk类是一个具体的装饰器类,其继承了抽象的装饰器类,并且引用了一个具体的组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Milk</span> <span class="keyword">extends</span> <span class="title">CondimentDecorator</span></span>&#123;</span><br><span class="line">    Beverage beverage;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Milk</span><span class="params">(Beverage beverage)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beverage=beverage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.getDescription()+<span class="string">", Milk"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.30</span>+beverage.cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Soy类是一个具体的装饰器类,其继承了抽象的装饰器类,并且引用了一个具体的组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Soy</span> <span class="keyword">extends</span> <span class="title">CondimentDecorator</span></span>&#123;</span><br><span class="line">    Beverage beverage;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Soy</span><span class="params">(Beverage beverage)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beverage=beverage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.getDescription()+<span class="string">", Soy"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.4</span>+beverage.cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Whip类是一个具体的装饰器类,其继承了抽象的装饰器类,并且引用了一个具体的组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Whip</span> <span class="keyword">extends</span> <span class="title">CondimentDecorator</span></span>&#123;</span><br><span class="line">    Beverage beverage;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Whip</span><span class="params">(Beverage beverage)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beverage=beverage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.getDescription()+<span class="string">", Whip"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span>+beverage.cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecoratorPattern</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">    	<span class="comment">//每个具体的组件都可以单独使用</span></span><br><span class="line">        Beverage beverage=<span class="keyword">new</span> Espresso();</span><br><span class="line">        System.out.println(beverage.getDescription()+<span class="string">","</span>+beverage.cost());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//也可以使用多个装饰器对象包装一个具体的组件,扩展了具体组件的功能而不必修改具体组件的代码.</span></span><br><span class="line">        Beverage beverage1=<span class="keyword">new</span> Whip(<span class="keyword">new</span> Mocha(<span class="keyword">new</span> Mocha(beverage)));</span><br><span class="line">        System.out.println(beverage1.getDescription()+<span class="string">","</span>+beverage1.cost());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//也可以使用多个装饰器对象包装一个具体的组件,扩展了具体组件的功能而不必修改具体组件的代码.</span></span><br><span class="line">        Beverage beverage2=<span class="keyword">new</span> Soy(<span class="keyword">new</span> Soy(<span class="keyword">new</span> Milk(<span class="keyword">new</span> HouseBlend())));</span><br><span class="line">        System.out.println(beverage2.getDescription()+<span class="string">","</span>+beverage2.cost());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Java_I/O中的装饰者设计模式">Java I/O中的装饰者设计模式</h2><p><img src="http://7xonn1.com1.z0.glb.clouddn.com/java_io_%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt="Java IO中装饰者模式"></p>
<h3 id="实现自己的装饰者">实现自己的装饰者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FilterInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by think on 2015/12/25.</span><br><span class="line"> */</span></span><br><span class="line"> <span class="comment">//具体了装饰器类继承自FilterInputStream抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LowerCaseInputStream</span> <span class="keyword">extends</span> <span class="title">FilterInputStream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LowerCaseInputStream</span><span class="params">(InputStream in)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(in);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c=<span class="keyword">super</span>.read();</span><br><span class="line">        <span class="keyword">return</span> c==-<span class="number">1</span>?<span class="number">0</span>:Character.toLowerCase(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> read(b,<span class="number">0</span>,b.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="keyword">super</span>.read(b, off, len);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=off;i&lt;off+result;i++)&#123;</span><br><span class="line">            b[i]=(<span class="keyword">byte</span>)Character.toLowerCase((<span class="keyword">char</span>)b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Java_I/O类">Java I/O类</h2><h3 id="输出流">输出流</h3><p>Java基本的输出流类是java.io.OutputStream这个抽象类提供了写入数据的基本方法.OutputStream的子类使用这些方法向某种特定介质写入数据.FileOutputStream使用这些方法将数据写入文件.TelnetOutputStream使用这些方法将数据写入网络连接.ByteArrayOutputStream使用这些方法将数据写入可扩展的字节数组.</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>public abstract void write(int b) throws IOException</td>
<td>这个方法接受一个0到255间的整数作为参数,将对应的字节写入到输出流中.</td>
</tr>
<tr>
<td>public void write(byte[] data) throws IOException</td>
<td>这个方法接受一个字节数组,将字节数组中的所有字节写入到输出流中.</td>
</tr>
<tr>
<td>public void write(byte[] data,int offset,int length)</td>
<td>这个方法接受一个字节数组,将字节数组中某范围内的所有字节写入到输出流中.</td>
</tr>
<tr>
<td>public void flush() throws IOException</td>
<td>这个方法强迫带缓存的输出流将其缓存的数据写入到底层的输出流中.</td>
</tr>
<tr>
<td>public void close() throws IOException</td>
<td>关闭一个流,释放与这个流关联的所有资源(文件句柄或端口)</td>
</tr>
</tbody>
</table>
<h3 id="BufferedOutputStream类分析">BufferedOutputStream类分析</h3><p>这个类可以看做是装饰者模式中装饰者的一个具体的类,这个类继承自FilterOutputStream类,FilterOutputStream类作为一个具体装饰者都要继承的一个抽象类,<br>这个类特殊之处在于,其设置了一个缓存数组,如果直接向其写入,其会将其缓存在缓存数组,直到其写满后才将其缓存的数据一起写入具体的输出流组件,所以,如果在最后关闭其底层的具体的输出流组件时,如果没有将其缓存的数组进行写入,则会导致数据丢失.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedOutputStream</span> <span class="keyword">extends</span> <span class="title">FilterOutputStream</span> </span>&#123;</span><br><span class="line">    <span class="comment">//其维护的一个缓存字节数组</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">byte</span> buf[];</span><br><span class="line">    <span class="comment">//表示缓存数组中已经写入的字节数</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BufferedOutputStream</span><span class="params">(OutputStream out)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//默认设置缓存字节数组大小为8192</span></span><br><span class="line">        <span class="keyword">this</span>(out, <span class="number">8192</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BufferedOutputStream</span><span class="params">(OutputStream out, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(out);</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Buffer size &lt;= 0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        buf = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将缓存的字节数组写入输出链中下一个输出流</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushBuffer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            out.write(buf, <span class="number">0</span>, count);</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count &gt;= buf.length) &#123;</span><br><span class="line">            <span class="comment">//如果已经写满缓存数组,则将缓存数组刷写入输出链中下一个输出流</span></span><br><span class="line">            flushBuffer();</span><br><span class="line">        &#125;</span><br><span class="line">        buf[count++] = (<span class="keyword">byte</span>)b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (len &gt;= buf.length) &#123;</span><br><span class="line">            <span class="comment">/* If the request length exceeds the size of the output buffer,</span><br><span class="line">               flush the output buffer and then write the data directly.</span><br><span class="line">               In this way buffered streams will cascade harmlessly. */</span></span><br><span class="line">            flushBuffer();</span><br><span class="line">            out.write(b, off, len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len &gt; buf.length - count) &#123;</span><br><span class="line">            flushBuffer();</span><br><span class="line">        &#125;</span><br><span class="line">        System.arraycopy(b, off, buf, count, len);</span><br><span class="line">        count += len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将缓存数组已有的缓存数据刷写到输出链中下一个输出流</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        flushBuffer();</span><br><span class="line">        <span class="comment">//同时调用输出链中下一个输出流的刷写方法</span></span><br><span class="line">        out.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输入流">输入流</h3><p>Java的基本输入流类是java.io.InputStream这个抽象类,其具体的子类可以使用这些方法从某种特定的介质中读取数据,如FileInputStream从文件中读取数据.TelnetInputStream从网络连接中读取数据.ByteArrayInputStream从字节数组中读取数据.</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>public abstract int read() throws IOException</td>
<td>这个方法会阻塞直到流中有一个字节可以读取,并返回一个0到255的整数,返回-1表示流结束</td>
</tr>
<tr>
<td>public int read(byte[] input) throws IOException</td>
<td>这个方法尝试填充input数组,并填充已可读的字节数据,返回可读的字节数,返回-1表示流结束</td>
</tr>
<tr>
<td>public int read(byte[] input,int offset,int length) throws IOException</td>
<td>这个方法尝试填充input数组的从偏移offset到length长度的位置,并填充已读取的字节数,返回已读取的字节数,返回-1表示流结束</td>
</tr>
<tr>
<td>public long skip(long n) throws IOException</td>
<td>这个方法跳过流中指定长度的数据,从新位置开始处理输入流</td>
</tr>
<tr>
<td>public int available() throws IOException</td>
<td>这个方法确定不阻塞情况下流中至少可以读取的字节数</td>
</tr>
<tr>
<td>public void close() throws IOException</td>
<td>这个方法关闭输入流</td>
</tr>
<tr>
<td>public void mark(int readAheadLimit)</td>
<td>这个方法</td>
</tr>
</tbody>
</table>
<h3 id="BufferedInputStream类分析">BufferedInputStream类分析</h3>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/12/09/string/" title="Java字符串类型" itemprop="url">Java字符串类型</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="rookiedong" target="_blank" itemprop="author">rookiedong</a>
		
  <p class="article-time">
    <time datetime="2015-12-09T15:10:14.000Z" itemprop="datePublished"> 发表于 2015-12-09</time>
    
  </p>
</header>
    <div class="article-content">
        
        
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/12/06/qiniu_helper/" title="Qiniu Helper" itemprop="url">Qiniu Helper</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="rookiedong" target="_blank" itemprop="author">rookiedong</a>
		
  <p class="article-time">
    <time datetime="2015-12-06T15:00:59.000Z" itemprop="datePublished"> 发表于 2015-12-06</time>
    
  </p>
</header>
    <div class="article-content">
        
        
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/12/06/kibana_and_data_visulization/" title="集成ElasticSearch和Kibana4的SQLFire集群监控项目" itemprop="url">集成ElasticSearch和Kibana4的SQLFire集群监控项目</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="rookiedong" target="_blank" itemprop="author">rookiedong</a>
		
  <p class="article-time">
    <time datetime="2015-12-06T14:57:23.000Z" itemprop="datePublished"> 发表于 2015-12-06</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="监控手段">监控手段</h2><ul>
<li>基于SQLFire系统表和SQLFire节点状态查询命令(可以获取各个表的内存大小和表在节点间的负载信息,各个节点内存消耗和各个节点的状态信息等)</li>
<li>基于SQLFire节点的输出日志(通过实时获取各个节点的日志的输出信息并进行实时分析,可以获取SQLFire集群还有各个节点的SQLFire语句执行情况等)</li>
</ul>
<h2 id="基于SQLFire系统表和SQLFire节点状态查询命令">基于SQLFire系统表和SQLFire节点状态查询命令</h2><p> 主要通过memanalysis.sh脚本实现,该脚本部署于任意一台可以访问SQLFire集群中任意节点的主机上.脚本可以通过crontab程序定时调用运行.</p>
<h3 id="配置参数">配置参数</h3><ol>
<li>SQLFire内存系统表查询语句文件路径</li>
<li>内存监控日志存储路径</li>
<li>节点状态监控日志存储路径</li>
<li>SQLFire集群各个节点的HOST列表(IP列表)</li>
<li>客户端IP(客户端IP和端口号为SQLFire集群中任意一个能提供客户端访问的节点的IP和端口号)</li>
<li>客户端端口号</li>
<li>节点的内存大小上限(单位:KB)</li>
<li>节点的内存阈值警告百分比</li>
<li>节点的内存负载倾斜阈值警告百分比</li>
<li>被监控的表列表</li>
<li>各个表的内存大小上限列表(单位:KB)</li>
<li>表的内存阈值警告百分比</li>
<li>表的内存负载倾斜阈值警告百分比</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sql_file=/app/sqlfire_script/sql/querymem.sql&#10;&#10;querymem_log_file=/app/sqlfire_script/log/querymem.log&#10;check_status_log_file=/app/sqlfire_script/log/check_status.log&#10;readonly hosts=(cvs-dbps01 cvs-dbps02 cvs-dbps04 cvs-dbps05 cvs-dbps06)&#10;readonly client_bind_address=$1&#10;readonly client_port=$2&#10;&#10;#unit size kb&#10;readonly ds_memory_max=$((8*1024*1024))&#10;readonly ds_memory_threshold=0.9&#10;readonly ds_load_lean_threshold=0.1&#10;&#10;readonly tables_name=(&#34;APP.AIRLINES&#34; &#34;APP.CITIES&#34; &#34;APP.COUNTRIES&#34;)&#10;&#10;#unit size kb&#10;readonly tables_memory_max=(10 20 30)&#10;readonly tables_memory_threshold=(0.9 0.9 0.9)&#10;readonly table_load_lean_threshold=0.1</span><br></pre></td></tr></table></figure>
<h3 id="执行命令">执行命令</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#&#32534;&#36753;/etc/crontab&#25991;&#20214;&#10;vim /etc/crontab&#10;#&#21152;&#20837;&#22914;&#19979;&#19968;&#34892;&#20195;&#30721;&#20445;&#23384;&#36864;&#20986;&#10;*/5 * * * * root sh /app/sqlfire/memanalysis.sh 192.168.1.1 1528</span><br></pre></td></tr></table></figure>
<h3 id="运行环境">运行环境</h3><p>脚本的执行主机必须安装sshpass,该程序可以实现非交互的Shell密码验证</p>
<h3 id="内存信息系统表">内存信息系统表</h3><p>查看集群节点和所存储的表的内存消耗主要通过查看SQLFire内存信息系统表(SYS.MEMORYANALYTICS)</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>TABLE_NAME</td>
<td>表名</td>
</tr>
<tr>
<td>ID</td>
<td>每个成员都有唯一ID,格式为hostname(process_id)member_number:udp_port/tcp_port</td>
</tr>
<tr>
<td>HOST</td>
<td>主机名</td>
</tr>
<tr>
<td>TOTAL_SIZE</td>
<td>总内存大小</td>
</tr>
<tr>
<td>NUM_ROWS</td>
<td>行数</td>
</tr>
</tbody>
</table>
<p><img src="http://7xonn1.com1.z0.glb.clouddn.com/memoryoutput.JPG" alt="SYS.MEMORYANALYTICS Table Output"></p>
<h3 id="节点状态查询命令">节点状态查询命令</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#&#26597;&#35810;Locator&#33410;&#28857;&#29366;&#24577;&#21629;&#20196;&#10;sqlf locator status -dir=locator&#10;#&#26597;&#35810;Server&#33410;&#28857;&#29366;&#24577;&#21629;&#20196;&#10;sqlf server status -dir=server1&#10;#&#20351;&#29992;sshpass&#23454;&#29616;&#38750;&#20132;&#20114;&#24335;Shell&#26597;&#35810;&#33410;&#28857;&#29366;&#24577;&#21629;&#20196;&#10;sshpass -p &#34;ocnosql&#34; ssh ocnosql@$hostname -o StrictHostKeyChecking=no &#34;/app/sqlfire/bin/sqlf locator status -dir=/app/sqlfire_work/locator;/app/sqlfire/bin/sqlf server status -dir=/app/sqlfire_work/server1&#34;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>状态</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Waiting(等待)</td>
<td>存储节点等待其他节点启动后实现数据的同步更新</td>
</tr>
<tr>
<td>Stopped(停止)</td>
<td>节点停止运行</td>
</tr>
<tr>
<td>Running(运行)</td>
<td>节点正在运行</td>
</tr>
</tbody>
</table>
<h3 id="输出信息">输出信息</h3><p>内存监控信息输出至querymem_log_file变量指定的文件下,输出格式为:</p>
<ul>
<li>[ERROR|NORMAL] [ start_time:START_TIME timeslape:TIMESLAPEs ] (QUERY_MESSAGE_INFO)</li>
</ul>
<p>其中日志开头出现NORMAL,表明各个节点和各个表的内存消耗百分比和内存负载倾斜百分比在阈值以下.日志开头出现ERROR,表明至少一个节点或一个表其内存消耗百分比或内存负载倾斜百分比超过阈值,也表明内存检查执行失败,同时日志后面具体的信息会出现”execute fail!”.每条日志消息也同时给出开始执行时间和执行时间.</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>节点</td>
<td>节点主机名字,工作目录名和进程号,节点消耗的内存大小和存储数据的行数,节点消耗内存百分比和节点内存负载倾斜百分比</td>
</tr>
<tr>
<td>表</td>
<td>表名字,表的内存大小,表的总行数,表的内存消耗百分比和表的内存倾斜百分比在节点间的分布</td>
</tr>
<tr>
<td>内存异常信息</td>
<td>异常节点数和异常节点列表(内存百分比超过阈值和负载倾斜超过阈值),异常表数和异常表列表(内存百分比超过阈值和负载倾斜超过阈值)</td>
</tr>
<tr>
<td>其他异常信息</td>
<td>集群中存在的表不在脚本配置参数中,脚本配置参数中存在集群中不存在的表</td>
</tr>
</tbody>
</table>
<p><img src="http://7xonn1.com1.z0.glb.clouddn.com/query_mem.JPG" alt="Query Memory File Is Output"></p>
<p>节点状态监控信息输出至check_status_log_file变量指定的文件下,输出格式为:</p>
<ul>
<li>[ERROR|NORMAL] [ start_time:START_TIME timeslape:TIMESLAPEs ] (STATUS_MESSAGE_INFO)</li>
</ul>
<p>其中日志开头出现出现NORMAL,表明各个节点的运行状态正常(Running).日志开头出现ERROR,表明至少有一个节点的运行状态不正常(Stopped或Waiting),同时也表明内存状态检查执行失败,同时日志后面具体的信息会出现”execute fail!”.每条日志消息也同时给出开始执行时间和执行时间.</p>
<p>Tip: <strong>由于首先开始检查的是节点状态,如果节点状态检查执行失败,后续内存检查将不进行.</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>节点</td>
<td>节点主机名字,工作目录名和进程号,节点状态</td>
</tr>
<tr>
<td>异常信息</td>
<td>异常状态节点数</td>
</tr>
</tbody>
</table>
<p><img src="http://7xonn1.com1.z0.glb.clouddn.com/check_status.JPG" alt="Check Staus File Is Output"></p>
<h2 id="基于SQLFire节点的输出日志">基于SQLFire节点的输出日志</h2><p>  主要通过monitor.sh脚本实现,该脚本部署于所有SQLFire集群主机上,每个脚本运行实例负责监控一个节点的日志输出.每个脚本程序作为一个Linux后台程序,会持续运行不会自动退出.</p>
<h3 id="配置参数-1">配置参数</h3><ol>
<li>日志文件路径</li>
<li>severe级别日志输出文件路径</li>
<li>error级别日志输出文件路径</li>
<li>warnning级别日志输出文件路径</li>
<li>info级别日志输出文件路径</li>
<li>节点名字(节点名字也就是节点工作目录名)</li>
<li>主机名字</li>
<li>SELECT语句存储文件路径</li>
<li>UPDATE语句存储文件路径</li>
<li>DELETE语句存储文件路径</li>
<li>CREATE语句存储文件路径</li>
<li>INSERT语句存储文件路径</li>
<li>DROP语句存储文件路径</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readonly log_file=/app/sqlfire_log/server1/server1.log&#10;readonly severe_log_dir=/app/sqlfire_script/log/severe_log_dir&#10;readonly error_log_dir=/app/sqlfire_script/log/error_log_dir&#10;readonly warnning_log_dir=/app/sqlfire_script/log/warnning_log_dir&#10;readonly info_log_dir=/app/sqlfire_script/log/info_log_dir&#10;readonly member_name=server1&#10;readonly host_name=$HOST&#10;readonly store_select_sql=/app/sqlfire_script/log/info_select_log_dir&#10;readonly store_update_sql=/app/sqlfire_script/log/info_update_log_dir&#10;readonly store_delete_sql=/app/sqlfire_script/log/info_delete_log_dir&#10;readonly store_create_sql=/app/sqlfire_script/log/info_create_log_dir&#10;readonly store_insert_sql=/app/sqlfire_script/log/info_insert_log_dir&#10;readonly store_drop_sql=/app/sqlfire_script/log/info_drop_log_dir</span><br></pre></td></tr></table></figure>
<h3 id="执行命令-1">执行命令</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh /app/sqlfire/monitor.sh &#38;</span><br></pre></td></tr></table></figure>
<h3 id="日志等级">日志等级</h3><p>SQLFire输出的日志信息包含了7个级别,前四个级别和含义如下表:</p>
<table>
<thead>
<tr>
<th>日志等级</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>severe</td>
<td>日志安全最高等级,出现该等级日志意味着系统存在严重错误阻止系统正常运行,需要关闭或重启集群的一部分节点去修复这个问题</td>
</tr>
<tr>
<td>error</td>
<td>意味着某些操作出现错误</td>
</tr>
<tr>
<td>warnning</td>
<td>警告信息</td>
</tr>
<tr>
<td>info</td>
<td>正常输出信息</td>
</tr>
</tbody>
</table>
<h3 id="日志分析规则">日志分析规则</h3><ol>
<li>server成员启动后会保持与每个locator的通信,通过日志监控每个server与locator的连接关系</li>
<li>每个server成员或locator成员在集群中有某个成员离开后会立即在日志中进行记录,用于监控成员的状态</li>
<li>成员加入后会在locator成员日志中进行记录</li>
<li>客户端连接一个server成员后,在该server成员日志中会记录客户端的执行请求(失败,错误或成功)</li>
<li>select,update,delete请求有可能转发给其他节点,在每个节点上会跟踪其上的请求.可以监控客户端执行请求数与集群中总的请求数.</li>
<li>warnning,error和severe级别日志说明集群出现异常,需要特别关注</li>
<li>insert操作会在其直连的server日志上进行记录,但如果操作发生转发,其他被接受转发请求的节点的日志不会明显打印日志消息.</li>
</ol>
<h3 id="输出信息-1">输出信息</h3><table>
<thead>
<tr>
<th>日志等级</th>
<th>记录信息</th>
</tr>
</thead>
<tbody>
<tr>
<td>servere</td>
<td>所有servere级别日志</td>
</tr>
<tr>
<td>error</td>
<td>所有error级别日志</td>
</tr>
<tr>
<td>warnning</td>
<td>所有warnning级别日志</td>
</tr>
<tr>
<td>info</td>
<td>server与locator断开连接信息,成员离开信息,成员加入信息,客户端执行请求信息(成功,失败,错误)</td>
</tr>
</tbody>
</table>
<p><img src="http://7xonn1.com1.z0.glb.clouddn.com/rizhi_out.JPG" alt="Log File Is Output"></p>
<h2 id="集成ElasticSearch和Kibana4">集成ElasticSearch和Kibana4</h2><p> 不管是内存状态,节点状态或节点日志输出信息都是记录于文本中,通过查看文本信息是无法直观的了解集群的运行状态.所以需要将文本数据进行可视化,通过可视化的方式观察集群的运行状态.通过了解,发现集成ElasticSearch(以下简称ES)和Kibana可以实现这个目的.ES是一种文本搜索和分析引擎,在这里将ES作为一种文档存储服务器(将监控数据以Json方式存储于ES中),而Kibana作为ES一种前置组件,可以将ES中存储的文档数据以Kibana提供的多种图表进行可视化展现.且使用ES还有一种好处是,ES提供了简单的RestFul API方式进行交互,这样可以直接改写监控脚本,在脚本中使用简单的curl命令将监控数据索引至ES中.</p>
<p>下图展现集成ES与Kibana后的SQLFire监控架构图<br><img src="http://7xonn1.com1.z0.glb.clouddn.com/es_kibana.png?imageView/2/w/919/q/100" alt="SQLFire Monitor Project Architecture Diagram"></p>
<h3 id="ES索引和类型定义">ES索引和类型定义</h3><table>
<thead>
<tr>
<th>索引名</th>
<th>类型</th>
<th>字段定义</th>
</tr>
</thead>
<tbody>
<tr>
<td>sqlfire-monitor-node-static-info</td>
<td>node-name</td>
<td>主机名和节点工作目录名唯一标识符,主机名,节点工作目录名,进程号,节点状态,已使用内存大小,内存使用率,行数,内存负载倾斜百分比</td>
</tr>
<tr>
<td>sqlfire-monitor-table-static-info</td>
<td>table-name</td>
<td>表名,表大小,表内存使用率,行数,表负载倾斜百分比最大值</td>
</tr>
<tr>
<td>sqlfire-monitor-node-dynamic-info</td>
<td>node-info</td>
<td>主机名和节点工作目录名唯一标识符,主机名,节点工作目录名,进程号,已使用内存大小,行数,内存使用率,内存负载倾斜百分比,时间戳(Unix时间戳毫秒值)</td>
<td></td>
</tr>
<tr>
<td>sqlfire-monitor-table-dynamic-info</td>
<td>table-info</td>
<td>表名,表大小,表行数,表内存使用率,表负载倾斜百分比最大值,时间戳(Unix时间戳毫秒值)</td>
</tr>
<tr>
<td>sqlfire-monitor-table-node-info</td>
<td>table-node-info</td>
<td>表名,节点名,表行数,表大小</td>
</tr>
<tr>
<td>sqlfire-monitor-server-locator-info</td>
<td>server-host<em>server-name</em>locator-host*locator-name</td>
<td>Locator主机名和Locator工作目录名唯一ID,Server主机名,Server工作目录名,连接状态</td>
</tr>
<tr>
<td>sqlfire-monitor-member-last-info</td>
<td>member-last-info</td>
<td>主机名,进程号,最近一次状态,最近一次状态时间</td>
</tr>
<tr>
<td>sqlfire-monitor-error-log-info</td>
<td>error-log</td>
<td>主机名,节点工作目录名,时间戳(Unix时间戳毫秒值)</td>
</tr>
<tr>
<td>sqlfire-monitor-warnning-log-info</td>
<td>warnning-log</td>
<td>主机名,节点工作目录名,时间戳(Unix时间戳毫秒值)</td>
</tr>
<tr>
<td>sqlfire-monitor-servere-log-info</td>
<td>servere-log</td>
<td>主机名,节点工作目录名,时间戳(Unix时间戳毫秒值)</td>
</tr>
<tr>
<td>sqlfire-monitor-error-sql-info</td>
<td>error-sql</td>
<td>主机名,节点工作目录名,错误SQL语句,时间戳(Unix时间戳毫秒值)</td>
</tr>
<tr>
<td>sqlfire-monitor-fail-sql-info</td>
<td>fail-sql</td>
<td>主机名,节点工作目录名,失败SQL语句,时间戳(Unix时间戳毫秒值)</td>
</tr>
<tr>
<td>sqlfire-monitor-select-sql-info</td>
<td>select-sql</td>
<td>主机名,节点工作目录名,时间戳(Unix时间戳毫秒值)</td>
</tr>
<tr>
<td>sqlfire-monitor-update-sql-info</td>
<td>update-sql</td>
<td>主机名,节点工作目录名,时间戳(Unix时间戳毫秒值)</td>
</tr>
<tr>
<td>sqlfire-monitor-delete-sql-info</td>
<td>delete-sql</td>
<td>主机名,节点工作目录名,时间戳(Unix时间戳毫秒值)</td>
</tr>
<tr>
<td>sqlfire-monitor-direct-insert-sql-info</td>
<td>direct-insert-sql</td>
<td>主机名,节点工作目录名,时间戳(Unix时间戳毫秒值)</td>
</tr>
<tr>
<td>sqlfire-monitor-direct-select-sql-info</td>
<td>direct-select-sql</td>
<td>主机名,节点工作目录名,时间戳(Unix时间戳毫秒值)</td>
</tr>
<tr>
<td>sqlfire-monitor-direct-update-sql-info</td>
<td>direct-update-sql</td>
<td>主机名,节点工作目录名,时间戳(Unix时间戳毫秒值)</td>
</tr>
<tr>
<td>sqlfire-monitor-direct-delete-sql-info</td>
<td>direct-delete-sql</td>
<td>主机名,节点工作目录名,时间戳(Unix时间戳毫秒值)</td>
</tr>
</tbody>
</table>
<h3 id="映射和删除ES索引">映射和删除ES索引</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XDELETE http://localhost:9200/sqlfire-monitor-node-static-info/&#10;curl -XPUT http://localhost:9200/sqlfire-monitor-node-static-info -d &#39;&#123;&#10;  &#34;mappings&#34;:&#123;&#10;    &#34;_default_&#34;:&#123;&#10;      &#34;properties&#34;:&#123;&#10;           &#34;id&#34;:&#123;&#34;type&#34;:&#34;string&#34;,&#34;index&#34;:&#34;not_analyzed&#34;&#125;,&#10;           &#34;host&#34;:&#123;&#34;type&#34;:&#34;string&#34;,&#34;index&#34;:&#34;not_analyzed&#34;&#125;,&#10;           &#34;mem_name&#34;:&#123;&#34;type&#34;:&#34;string&#34;,&#34;index&#34;:&#34;not_analyzed&#34;&#125;,&#10;           &#34;pid&#34;:&#123;&#34;type&#34;:&#34;integer&#34;&#125;,&#10;           &#34;status&#34;:&#123;&#34;type&#34;:&#34;string&#34;,&#34;index&#34;:&#34;not_analyzed&#34;&#125;,&#10;           &#34;mem_size&#34;:&#123;&#34;type&#34;:&#34;double&#34;&#125;,&#10;           &#34;mem_used_percent&#34;:&#123;&#34;type&#34;:&#34;double&#34;&#125;,&#10;           &#34;rows&#34;:&#123;&#34;type&#34;:&#34;integer&#34;&#125;,&#10;           &#34;mem_load_lean_percent&#34;:&#123;&#34;type&#34;:&#34;double&#34;&#125;&#10;    &#125;&#10;  &#125;&#10;  &#125;&#10;&#125;&#10;&#39;;&#10;curl -XDELETE http://localhost:9200/sqlfire-monitor-table-static-infoo/&#10;curl -XPUT http://localhost:9200/sqlfire-monitor-table-static-info -d &#39;&#123;&#10;    &#34;mappings&#34;:&#123;&#10;      &#34;_default_&#34;:&#123;&#10;        &#34;properties&#34;:&#123;&#10;          &#34;table_name&#34;:&#123;&#34;type&#34;:&#34;string&#34;,&#34;index&#34;:&#34;not_analyzed&#34;&#125;,&#10;          &#34;table_size&#34;:&#123;&#34;type&#34;:&#34;double&#34;&#125;,&#10;          &#34;mem_used_percent&#34;:&#123;&#34;type&#34;:&#34;double&#34;&#125;,&#10;          &#34;rows&#34;:&#123;&#34;type&#34;:&#34;integer&#34;&#125;,&#10;          &#34;max_load_lean_percent&#34;:&#123;&#34;type&#34;:&#34;double&#34;&#125;&#10;          &#125;&#10;        &#125;&#10;    &#125;&#10; &#125;&#39;;&#10;curl -XDELETE http://localhost:9200/sqlfire-monitor-node-dynamic-info/&#10;curl -XPUT http://localhost:9200/sqlfire-monitor-node-dynamic-info -d &#39;&#123;&#10;  &#34;mappings&#34;:&#123;&#10;    &#34;_default_&#34;:&#123;&#10;      &#34;properties&#34;:&#123;&#10;           &#34;id&#34;:&#123;&#34;type&#34;:&#34;string&#34;,&#34;index&#34;:&#34;not_analyzed&#34;&#125;,&#10;           &#34;host&#34;:&#123;&#34;type&#34;:&#34;string&#34;,&#34;index&#34;:&#34;not_analyzed&#34;&#125;,&#10;           &#34;mem_name&#34;:&#123;&#34;type&#34;:&#34;string&#34;,&#34;index&#34;:&#34;not_analyzed&#34;&#125;,&#10;           &#34;pid&#34;:&#123;&#34;type&#34;:&#34;integer&#34;&#125;,&#10;           &#34;mem_size&#34;:&#123;&#34;type&#34;:&#34;double&#34;&#125;,&#10;           &#34;mem_used_percent&#34;:&#123;&#34;type&#34;:&#34;double&#34;&#125;,&#10;           &#34;rows&#34;:&#123;&#34;type&#34;:&#34;integer&#34;&#125;,&#10;           &#34;mem_load_lean_percent&#34;:&#123;&#34;type&#34;:&#34;double&#34;&#125;,&#10;           &#34;timestamp&#34;:&#123;&#34;type&#34;:&#34;date&#34;&#125;&#10;        &#125;&#10;      &#125;&#10;  &#125;&#10;&#125;&#10;&#39;;&#10;curl -XDELETE http://localhost:9200/sqlfire-monitor-table-dynamic-info/&#10;curl -XPUT http://localhost:9200/sqlfire-monitor-table-dynamic-info -d &#39;&#123;&#10;  &#34;mappings&#34;:&#123;&#10;    &#34;_default_&#34;:&#123;&#10;      &#34;properties&#34;:&#123;&#10;           &#34;table_name&#34;:&#123;&#34;type&#34;:&#34;string&#34;,&#34;index&#34;:&#34;not_analyzed&#34;&#125;,&#10;           &#34;table_size&#34;:&#123;&#34;type&#34;:&#34;double&#34;&#125;,&#10;           &#34;mem_name&#34;:&#123;&#34;type&#34;:&#34;string&#34;,&#34;index&#34;:&#34;not_analyzed&#34;&#125;,&#10;           &#34;mem_used_percent&#34;:&#123;&#34;type&#34;:&#34;double&#34;&#125;,&#10;           &#34;rows&#34;:&#123;&#34;type&#34;:&#34;integer&#34;&#125;,&#10;           &#34;max_load_lean_percent&#34;:&#123;&#34;type&#34;:&#34;double&#34;&#125;&#10;           &#34;timestamp&#34;:&#123;&#34;type&#34;:&#34;date&#34;&#125;&#10;        &#125;&#10;      &#125;&#10;  &#125;&#10;&#125;&#10;&#39;;&#10;curl -XDELETE http://localhost:9200/sqlfire-monitor-server-locator-info/&#10;curl -XPUT http://localhost:9200/sqlfire-monitor-server-locator-info -d &#39;&#123;&#10;     &#34;mappings&#34;:&#123;&#10;        &#34;_default_&#34;:&#123;&#10;          &#34;properties&#34;:&#123;&#10;            &#34;locator_id&#34;:&#123;&#34;type&#34;:&#34;string&#34;,&#34;index&#34;:&#34;not_analyzed&#34;&#125;,&#10;            &#34;server_host&#34;:&#123;&#34;type&#34;:&#34;string&#34;,&#34;index&#34;:&#34;not_analyzed&#34;&#125;,&#10;            &#34;server_name&#34;:&#123;&#34;type&#34;:&#34;string&#34;,&#34;index&#34;:&#34;not_analyzed&#34;&#125;,&#10;            &#34;connect_status&#34;:&#123;&#34;type&#34;:&#34;string&#34;,&#34;index&#34;:&#34;not_analyzed&#34;&#125;&#10;          &#125;&#10;        &#125;&#10;    &#125;&#10;&#125;&#39;;&#10;curl -XDELETE http://localhost:9200/sqlfire-monitor-member-last-info/&#10;curl -XPUT http://localhost:9200/sqlfire-monitor-member-last-info -d &#39;&#123;&#10;     &#34;mappings&#34;:&#123;&#10;        &#34;_default_&#34;:&#123;&#10;          &#34;properties&#34;:&#123;&#10;            &#34;host_name&#34;:&#123;&#34;type&#34;:&#34;string&#34;,&#34;index&#34;:&#34;not_analyzed&#34;&#125;,&#10;            &#34;pid&#34;:&#123;&#34;type&#34;:&#34;int&#34;&#125;,&#10;            &#34;last_status&#34;:&#123;&#34;type&#34;:&#34;string&#34;,&#34;index&#34;:&#34;not_analyzed&#34;&#125;,&#10;            &#34;last_status_timestamp&#34;:&#123;&#34;type&#34;:&#34;string&#34;,&#34;index&#34;:&#34;not_analyzed&#34;&#125;&#10;          &#125;&#10;        &#125;&#10;    &#125;&#10;&#125;&#39;;&#10;curl -XDELETE http://localhost:9200/sqlfire-monitor-error-log-info/&#10;curl -XPUT http://localhost:9200/sqlfire-monitor-error-log-info -d &#39;&#123;&#10;     &#34;mappings&#34;:&#123;&#10;        &#34;_default_&#34;:&#123;&#10;          &#34;properties&#34;:&#123;&#10;            &#34;host_name&#34;:&#123;&#34;type&#34;:&#34;string&#34;,&#34;index&#34;:&#34;not_analyzed&#34;&#125;,&#10;            &#34;mem_name&#34;:&#123;&#34;type&#34;:&#34;string&#34;,&#34;index&#34;:&#34;not_analyzed&#34;&#125;,&#10;            &#34;timestamp&#34;:&#123;&#34;type&#34;:&#34;date&#34;&#125;&#10;          &#125;&#10;        &#125;&#10;    &#125;&#10;&#125;&#39;;&#10;curl -XDELETE http://localhost:9200/sqlfire-monitor-servere-log-info/&#10;curl -XPUT http://localhost:9200/sqlfire-monitor-servere-log-info -d &#39;&#123;&#10;     &#34;mappings&#34;:&#123;&#10;        &#34;_default_&#34;:&#123;&#10;          &#34;properties&#34;:&#123;&#10;            &#34;host_name&#34;:&#123;&#34;type&#34;:&#34;string&#34;,&#34;index&#34;:&#34;not_analyzed&#34;&#125;,&#10;            &#34;mem_name&#34;:&#123;&#34;type&#34;:&#34;string&#34;,&#34;index&#34;:&#34;not_analyzed&#34;&#125;,&#10;            &#34;timestamp&#34;:&#123;&#34;type&#34;:&#34;date&#34;&#125;&#10;          &#125;&#10;        &#125;&#10;    &#125;&#10;&#125;&#39;;&#10;curl -XDELETE http://localhost:9200/sqlfire-monitor-warnning-log-info/&#10;curl -XPUT http://localhost:9200/sqlfire-monitor-warnning-log-info -d &#39;&#123;&#10;     &#34;mappings&#34;:&#123;&#10;        &#34;_default_&#34;:&#123;&#10;          &#34;properties&#34;:&#123;&#10;            &#34;host_name&#34;:&#123;&#34;type&#34;:&#34;string&#34;,&#34;index&#34;:&#34;not_analyzed&#34;&#125;,&#10;            &#34;mem_name&#34;:&#123;&#34;type&#34;:&#34;string&#34;,&#34;index&#34;:&#34;not_analyzed&#34;&#125;,&#10;            &#34;timestamp&#34;:&#123;&#34;type&#34;:&#34;date&#34;&#125;&#10;          &#125;&#10;        &#125;&#10;    &#125;&#10;&#125;&#39;;&#10;curl -XDELETE http://localhost:9200/sqlfire-monitor-error-sql-info/&#10;curl -XPUT http://localhost:9200/sqlfire-monitor-error-sql-info -d &#39;&#123;&#10;     &#34;mappings&#34;:&#123;&#10;        &#34;_default_&#34;:&#123;&#10;          &#34;properties&#34;:&#123;&#10;            &#34;host_name&#34;:&#123;&#34;type&#34;:&#34;string&#34;,&#34;index&#34;:&#34;not_analyzed&#34;&#125;,&#10;            &#34;mem_name&#34;:&#123;&#34;type&#34;:&#34;string&#34;,&#34;index&#34;:&#34;not_analyzed&#34;&#125;,&#10;            &#34;error_sql&#34;:&#123;&#34;type&#34;:&#34;string&#34;,&#34;index&#34;:&#34;not_analyzed&#34;&#125;,&#10;            &#34;timestamp&#34;:&#123;&#34;type&#34;:&#34;date&#34;&#125;&#10;          &#125;&#10;        &#125;&#10;    &#125;&#10;&#125;&#39;;&#10;curl -XDELETE http://localhost:9200/sqlfire-monitor-fail-sql-info/&#10;curl -XPUT http://localhost:9200/sqlfire-monitor-fail-sql-info -d &#39;&#123;&#10;     &#34;mappings&#34;:&#123;&#10;        &#34;_default_&#34;:&#123;&#10;          &#34;properties&#34;:&#123;&#10;            &#34;host_name&#34;:&#123;&#34;type&#34;:&#34;string&#34;,&#34;index&#34;:&#34;not_analyzed&#34;&#125;,&#10;            &#34;mem_name&#34;:&#123;&#34;type&#34;:&#34;string&#34;,&#34;index&#34;:&#34;not_analyzed&#34;&#125;,&#10;            &#34;fail_sql&#34;:&#123;&#34;type&#34;:&#34;string&#34;,&#34;index&#34;:&#34;not_analyzed&#34;&#125;,&#10;            &#34;timestamp&#34;:&#123;&#34;type&#34;:&#34;date&#34;&#125;&#10;          &#125;&#10;        &#125;&#10;    &#125;&#10;&#125;&#39;;&#10;curl -XDELETE http://localhost:9200/sqlfire-monitor-select-sql-info/&#10;curl -XPUT http://localhost:9200/sqlfire-monitor-select-sql-info -d &#39;&#123;&#10;     &#34;mappings&#34;:&#123;&#10;        &#34;_default_&#34;:&#123;&#10;          &#34;properties&#34;:&#123;&#10;            &#34;host_name&#34;:&#123;&#34;type&#34;:&#34;string&#34;,&#34;index&#34;:&#34;not_analyzed&#34;&#125;,&#10;            &#34;mem_name&#34;:&#123;&#34;type&#34;:&#34;string&#34;,&#34;index&#34;:&#34;not_analyzed&#34;&#125;,&#10;            &#34;timestamp&#34;:&#123;&#34;type&#34;:&#34;date&#34;&#125;&#10;          &#125;&#10;        &#125;&#10;    &#125;&#10;&#125;&#39;;&#10;curl -XDELETE http://localhost:9200/sqlfire-monitor-update-sql-info/&#10;curl -XPUT http://localhost:9200/sqlfire-monitor-update-sql-info -d &#39;&#123;&#10;     &#34;mappings&#34;:&#123;&#10;        &#34;_default_&#34;:&#123;&#10;          &#34;properties&#34;:&#123;&#10;            &#34;host_name&#34;:&#123;&#34;type&#34;:&#34;string&#34;,&#34;index&#34;:&#34;not_analyzed&#34;&#125;,&#10;            &#34;mem_name&#34;:&#123;&#34;type&#34;:&#34;string&#34;,&#34;index&#34;:&#34;not_analyzed&#34;&#125;,&#10;            &#34;timestamp&#34;:&#123;&#34;type&#34;:&#34;date&#34;&#125;&#10;          &#125;&#10;        &#125;&#10;    &#125;&#10;&#125;&#39;;&#10;curl -XDELETE http://localhost:9200/sqlfire-monitor-delete-sql-info/&#10;curl -XPUT http://localhost:9200/sqlfire-monitor-delete-sql-info -d &#39;&#123;&#10;     &#34;mappings&#34;:&#123;&#10;        &#34;_default_&#34;:&#123;&#10;          &#34;properties&#34;:&#123;&#10;            &#34;host_name&#34;:&#123;&#34;type&#34;:&#34;string&#34;,&#34;index&#34;:&#34;not_analyzed&#34;&#125;,&#10;            &#34;mem_name&#34;:&#123;&#34;type&#34;:&#34;string&#34;,&#34;index&#34;:&#34;not_analyzed&#34;&#125;,&#10;            &#34;timestamp&#34;:&#123;&#34;type&#34;:&#34;date&#34;&#125;&#10;          &#125;&#10;        &#125;&#10;    &#125;&#10;&#125;&#39;;&#10;curl -XDELETE http://localhost:9200/sqlfire-monitor-direct-insert-sql-info/&#10;curl -XPUT http://localhost:9200/sqlfire-monitor-direct-insert-sql-info -d &#39;&#123;&#10;     &#34;mappings&#34;:&#123;&#10;        &#34;_default_&#34;:&#123;&#10;          &#34;properties&#34;:&#123;&#10;            &#34;host_name&#34;:&#123;&#34;type&#34;:&#34;string&#34;,&#34;index&#34;:&#34;not_analyzed&#34;&#125;,&#10;            &#34;mem_name&#34;:&#123;&#34;type&#34;:&#34;string&#34;,&#34;index&#34;:&#34;not_analyzed&#34;&#125;,&#10;            &#34;timestamp&#34;:&#123;&#34;type&#34;:&#34;date&#34;&#125;&#10;          &#125;&#10;        &#125;&#10;    &#125;&#10;&#125;&#39;;&#10;curl -XDELETE http://localhost:9200/sqlfire-monitor-direct-select-sql-info/&#10;curl -XPUT http://localhost:9200/sqlfire-monitor-direct-select-sql-info -d &#39;&#123;&#10;     &#34;mappings&#34;:&#123;&#10;        &#34;_default_&#34;:&#123;&#10;          &#34;properties&#34;:&#123;&#10;            &#34;host_name&#34;:&#123;&#34;type&#34;:&#34;string&#34;,&#34;index&#34;:&#34;not_analyzed&#34;&#125;,&#10;            &#34;mem_name&#34;:&#123;&#34;type&#34;:&#34;string&#34;,&#34;index&#34;:&#34;not_analyzed&#34;&#125;,&#10;            &#34;timestamp&#34;:&#123;&#34;type&#34;:&#34;date&#34;&#125;&#10;          &#125;&#10;        &#125;&#10;    &#125;&#10;&#125;&#39;;&#10;curl -XDELETE http://localhost:9200/sqlfire-monitor-direct-update-sql-info/&#10;curl -XPUT http://localhost:9200/sqlfire-monitor-direct-update-sql-info -d &#39;&#123;&#10;     &#34;mappings&#34;:&#123;&#10;        &#34;_default_&#34;:&#123;&#10;          &#34;properties&#34;:&#123;&#10;            &#34;host_name&#34;:&#123;&#34;type&#34;:&#34;string&#34;,&#34;index&#34;:&#34;not_analyzed&#34;&#125;,&#10;            &#34;mem_name&#34;:&#123;&#34;type&#34;:&#34;string&#34;,&#34;index&#34;:&#34;not_analyzed&#34;&#125;,&#10;            &#34;timestamp&#34;:&#123;&#34;type&#34;:&#34;date&#34;&#125;&#10;          &#125;&#10;        &#125;&#10;    &#125;&#10;&#125;&#39;;&#10;curl -XDELETE http://localhost:9200/sqlfire-monitor-direct-delete-sql-info/&#10;curl -XPUT http://localhost:9200/sqlfire-monitor-direct-delete-sql-info -d &#39;&#123;&#10;     &#34;mappings&#34;:&#123;&#10;        &#34;_default_&#34;:&#123;&#10;          &#34;properties&#34;:&#123;&#10;            &#34;host_name&#34;:&#123;&#34;type&#34;:&#34;string&#34;,&#34;index&#34;:&#34;not_analyzed&#34;&#125;,&#10;            &#34;mem_name&#34;:&#123;&#34;type&#34;:&#34;string&#34;,&#34;index&#34;:&#34;not_analyzed&#34;&#125;,&#10;            &#34;timestamp&#34;:&#123;&#34;type&#34;:&#34;date&#34;&#125;&#10;          &#125;&#10;        &#125;&#10;    &#125;&#10;&#125;&#39;;</span><br></pre></td></tr></table></figure>
<h3 id="修改memanalysis-sh脚本实现向ES索引数据">修改memanalysis.sh脚本实现向ES索引数据</h3><p>  修改memanalysis.sh实现向ES索引数据并重命名为memanalysis_in_es.sh,在脚本中增加三个配置参数</p>
<ol>
<li>ES服务进程主机名</li>
<li>ES服务进程端口号</li>
<li>Json数据临时存储目录</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmp_json_data_dir=/app/sqlfire_script/tmp_json_data&#10;readonly es_host=&#34;localhost&#34;&#10;readonly es_port=9200</span><br></pre></td></tr></table></figure>
<h3 id="SQLFire节点静态监控面板">SQLFire节点静态监控面板</h3><table>
<thead>
<tr>
<th>面板名称</th>
<th>面板类型</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>SQLFire节点内存使用率分布图</td>
<td>饼图</td>
<td>设置内存使用率范围</td>
</tr>
<tr>
<td>SQLFire节点内存负载倾斜百分比分布图</td>
<td>饼图</td>
<td>设置内存负载倾斜百分比范围</td>
</tr>
<tr>
<td>SQLFire节点状态分布图</td>
<td>饼图</td>
<td></td>
</tr>
<tr>
<td>SQLFire主机内存使用柱状图</td>
<td>柱状图</td>
<td></td>
</tr>
<tr>
<td>SQLFire主机表行数存储柱状图</td>
<td>柱状图</td>
<td></td>
</tr>
<tr>
<td>SQLFire节点内存使用柱状图</td>
<td>柱状图</td>
<td></td>
</tr>
<tr>
<td>SQLFire节点表行数存储柱状图</td>
<td>柱状图</td>
</tr>
</tbody>
</table>
<p><img src="http://7xonn1.com1.z0.glb.clouddn.com/node_static_monitor.gif" alt="SQLFire Member Static Monitor"></p>
<h3 id="SQLFire表静态监控面板">SQLFire表静态监控面板</h3><table>
<thead>
<tr>
<th>面板名称</th>
<th>面板类型</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>SQLFire表内存使用率分布图</td>
<td>饼图</td>
<td>设置内存使用率范围</td>
</tr>
<tr>
<td>SQLFire表内存负载倾斜百分比最大值分布图</td>
<td>饼图</td>
<td>设置内存负载倾斜百分比范围</td>
</tr>
<tr>
<td>SQLFire表内存使用柱状图</td>
<td>柱状图</td>
<td></td>
</tr>
<tr>
<td>SQLFire表行数柱状图</td>
<td>柱状图</td>
</tr>
</tbody>
</table>
<p><img src="http://7xonn1.com1.z0.glb.clouddn.com/kibana_table_static_monitor.gif" alt="SQLFire Table Static Monitor"></p>
<h3 id="SQLFire表动态监控面板">SQLFire表动态监控面板</h3><table>
<thead>
<tr>
<th>面板名称</th>
<th>面板类型</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>SQLFire表内存大小变化图</td>
<td>折现图</td>
<td></td>
</tr>
<tr>
<td>SQLFire表行数变化图</td>
<td>折线图</td>
<td></td>
</tr>
<tr>
<td>SQLFire表内存使用率变化图</td>
<td>折线图</td>
<td></td>
</tr>
<tr>
<td>SQLFire表内存负载倾斜百分比最大值变化图</td>
<td>折线图</td>
</tr>
</tbody>
</table>
<h3 id="SQLFire节点动态监控面板">SQLFire节点动态监控面板</h3><table>
<thead>
<tr>
<th>面板名称</th>
<th>面板类型</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>SQLFire集群内存总使用变化图</td>
<td>折线图</td>
<td></td>
</tr>
<tr>
<td>SQLFire主机内存使用变化图</td>
<td>折线图</td>
<td></td>
</tr>
<tr>
<td>SQLFire节点内存使用变化图</td>
<td>折线图</td>
<td></td>
</tr>
<tr>
<td>SQLFire节点内存使用率变化图</td>
<td>折线图</td>
<td></td>
</tr>
<tr>
<td>SQLFire节点负载倾斜百分比变化图</td>
<td>折线图</td>
</tr>
</tbody>
</table>
<p><img src="http://7xonn1.com1.z0.glb.clouddn.com/node_dynamic_monitor.gif" alt="SQLFire Member Static Monitor"></p>
<h3 id="SQLFire节点和表关系监控面板">SQLFire节点和表关系监控面板</h3><table>
<thead>
<tr>
<th>面板名称</th>
<th>面板类型</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>SQLFire节点表数据构成图</td>
<td>柱状图</td>
<td>暂缺</td>
</tr>
<tr>
<td>SQLFire表数据节点承载分布图</td>
<td>柱状图</td>
<td>暂缺</td>
</tr>
</tbody>
</table>
<h3 id="修改monitor-sh脚本向ES索引数据">修改monitor.sh脚本向ES索引数据</h3><p>   修改monitor.sh实现向ES索引数据并重命名为monitor_in_es.sh,在脚本中增加三个配置参数</p>
<ol>
<li>ES服务进程主机名</li>
<li>ES服务进程端口号</li>
<li>Json数据临时存储目录</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmp_json_data_dir=/app/sqlfire_script/$1/tmp_json_data&#10;readonly es_host=&#34;localhost&#34;&#10;readonly es_port=9200</span><br></pre></td></tr></table></figure>
<h3 id="SQLFire基于日志监控面板">SQLFire基于日志监控面板</h3><table>
<thead>
<tr>
<th>面板名称</th>
<th>面板类型</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>SQLFireLocator连接服务状态图</td>
<td>饼图</td>
<td></td>
</tr>
<tr>
<td>SQLFire节点最近一次状态信息</td>
<td>列表</td>
<td></td>
</tr>
<tr>
<td>SQLFire节点Error级别日志信息</td>
<td>折线图</td>
<td></td>
</tr>
<tr>
<td>SQLFire节点WARNNING级别日志信息</td>
<td>折线图</td>
<td></td>
</tr>
<tr>
<td>SQLFire节点SERVERE级别日志信息</td>
<td>折线图</td>
<td></td>
</tr>
<tr>
<td>SQLFire节点错误SQL语句信息</td>
<td>折线图</td>
<td></td>
</tr>
<tr>
<td>SQLFire节点失败SQL语句信息</td>
<td>折线图</td>
<td></td>
</tr>
<tr>
<td>SQLFire节点SELECT语句信息</td>
<td>折线图</td>
<td>包括客户端直接请求和节点转发请求</td>
</tr>
<tr>
<td>SQLFire节点DELETE语句信息</td>
<td>折线图</td>
<td>包括客户端直接请求和节点转发请求</td>
</tr>
<tr>
<td>SQLFire节点UPDATE语句信息</td>
<td>折线图</td>
<td>包括客户端直接请求和节点转发请求</td>
</tr>
<tr>
<td>SQLFire节点直接INSERT语句信息</td>
<td>折线图</td>
<td>客户端直接请求</td>
</tr>
<tr>
<td>SQLFire节点直接SELECT语句信息</td>
<td>折线图</td>
<td>客户端直接请求</td>
</tr>
<tr>
<td>SQLFire节点直接DELETE语句信息</td>
<td>折线图</td>
<td>客户端直接请求</td>
</tr>
<tr>
<td>SQLFire节点直接UPDATE语句信息</td>
<td>折线图</td>
<td>客户端直接请求</td>
</tr>
</tbody>
</table>
<h2 id="搭建测试环境">搭建测试环境</h2><h3 id="系统环境">系统环境</h3><table>
<thead>
<tr>
<th>主机</th>
<th>ip地址</th>
<th>物理内存</th>
<th>操作系统</th>
<th>服务组件</th>
</tr>
</thead>
<tbody>
<tr>
<td>cvs-dbps01</td>
<td>20.26.20.28</td>
<td>4G</td>
<td>SUSE Linux Enterprise Server 11 SP3</td>
<td>Kibana服务,ES服务,Locator,Server01,Server02</td>
</tr>
<tr>
<td>cvs-dbps02</td>
<td>20.26.20.29</td>
<td>4G</td>
<td>SUSE Linux Enterprise Server 11 SP3</td>
<td>Locator,Server01,Server02</td>
</tr>
<tr>
<td>cvs-dbps04</td>
<td>20.26.20.31</td>
<td>4G</td>
<td>SUSE Linux Enterprise Server 11 SP3</td>
<td>Locator,Server01,Server02</td>
</tr>
<tr>
<td>cvs-dbps05</td>
<td>20.26.20.32</td>
<td>4G</td>
<td>SUSE Linux Enterprise Server 11 SP3</td>
<td>Locator,Server01,Server02</td>
</tr>
<tr>
<td>cvs-dbps06</td>
<td>20.26.20.33</td>
<td>4G</td>
<td>SUSE Linux Enterprise Server 11 SP3</td>
<td>Locator,Server01,Server02</td>
</tr>
</tbody>
</table>
<h3 id="服务安装">服务安装</h3><h2 id="参考">参考</h2><p><a href="https://github.com/dongjiaqiang/sqlfire_monitor_scripts.git" target="_blank" rel="external">集成ElasticSearch和Kibana4的SQLFire集群监控项目Github地址</a></p>
<h2 id="引用">引用</h2><p><a href="http://sqlfire.docs.pivotal.io/userguide/index.html" target="_blank" rel="external">SQLFire User Guide</a><br><a href="http://es.xiaoleilu.com/index.html" target="_blank" rel="external">Elasticsearch 权威指南(中文版)</a><br><a href="https://www.elastic.co/products/elasticsearch/" target="_blank" rel="external">Elasticsearch Office Website</a><br><a href="https://www.elastic.co/guide/en/kibana/current/index.html" target="_blank" rel="external">Kibana4 User Guide</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  


  

  

  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=null&verifier=wwewe&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/21212" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2016 
		
		<a href="/about" target="_blank" title="rookiedong">rookiedong</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fe6d1f421bbc9962127a50488f9ed37d1' type='text/javascript'%3E%3C/script%3E"));
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
